/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/webpack/buildin/amd-options.js":
/*!******************************************************!*\
  !*** ../node_modules/webpack/buildin/amd-options.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),

/***/ "../node_modules/webpack/buildin/global.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../node_modules/webpack/buildin/harmony-module.js":
/*!*********************************************************!*\
  !*** ../node_modules/webpack/buildin/harmony-module.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./js/main.js":
/*!********************!*\
  !*** ./js/main.js ***!
  \********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_ios_vh_fix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/ios-vh-fix */ "./js/utils/ios-vh-fix.js");
/* harmony import */ var _modules_form_validate_form__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/form-validate/form */ "./js/modules/form-validate/form.js");
/* harmony import */ var _modules_menu_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/menu/index */ "./js/modules/menu/index.js");



// ---------------------------------

window.addEventListener('DOMContentLoaded', function () {
  // Utils
  // ---------------------------------

  Object(_utils_ios_vh_fix__WEBPACK_IMPORTED_MODULE_0__["iosVhFix"])();

  // Modules
  // ---------------------------------

  // все скрипты должны быть в обработчике 'DOMContentLoaded', но не все в 'load'
  // в load следует добавить скрипты, не участвующие в работе первого экрана
  window.addEventListener('load', function () {
    var form = new _modules_form_validate_form__WEBPACK_IMPORTED_MODULE_1__["Form"]();
    window.form = form;
    form.init();
  });
});

// ---------------------------------

// ❗❗❗ обязательно установите плагины eslint, stylelint, editorconfig в редактор кода.

// привязывайте js не на классы, а на дата атрибуты (data-validate)

// вместо модификаторов .block--active используем утилитарные классы
// .is-active || .is-open || .is-invalid и прочие (обязателен нейминг в два слова)
// .select.select--opened ❌ ---> [data-select].is-open ✅

// выносим все в дата атрибуты
// url до иконок пинов карты, настройки автопрокрутки слайдера, url к json и т.д.

// для адаптивного JS используется matchMedia и addListener
// const breakpoint = window.matchMedia(`(min-width:1024px)`);
// const breakpointChecker = () => {
//   if (breakpoint.matches) {
//   } else {
//   }
// };
// breakpoint.addListener(breakpointChecker);
// breakpointChecker();

// используйте .closest(el)

/***/ }),

/***/ "./js/modules/form-validate/callback.js":
/*!**********************************************!*\
  !*** ./js/modules/form-validate/callback.js ***!
  \**********************************************/
/*! exports provided: callbacks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "callbacks", function() { return callbacks; });
var baseSuccessCallback = function baseSuccessCallback(event) {
  // В данном колбеке бэкендер, либо разработчик при необходимости будет писать запрос на отправку формы на сервер и обрабатывать возможные ошибки или успешную отправку формы на сервер
};
var baseErrorCallback = function baseErrorCallback(event) {
  event.preventDefault();
  // Данный коллбек используется при необходимости выполнить какое-либо действие помимо показа ошибок при попытке отправить неккорректные данные, он не связан с запросами на сервер
};

var callbacks = {
  base: {
    // Сбросс формы
    reset: true,
    // Таймаут сброса формы
    resetTimeout: 500,
    successCallback: baseSuccessCallback,
    errorCallback: baseErrorCallback
  }
};

/***/ }),

/***/ "./js/modules/form-validate/form.js":
/*!******************************************!*\
  !*** ./js/modules/form-validate/form.js ***!
  \******************************************/
/*! exports provided: Form */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Form", function() { return Form; });
/* harmony import */ var _validator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validator */ "./js/modules/form-validate/validator.js");
/* harmony import */ var _callback__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./callback */ "./js/modules/form-validate/callback.js");
/* harmony import */ var _init_phone_input__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init-phone-input */ "./js/modules/form-validate/init-phone-input.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }



var Form = /*#__PURE__*/function () {
  function Form() {
    _classCallCheck(this, Form);
    this._validator = new _validator__WEBPACK_IMPORTED_MODULE_0__["Validator"]();
    this._initPhoneInput = _init_phone_input__WEBPACK_IMPORTED_MODULE_2__["initPhoneInput"];
    this._callbacks = _callback__WEBPACK_IMPORTED_MODULE_1__["callbacks"];
  }
  _createClass(Form, [{
    key: "_resetSelect",
    value: function _resetSelect(select) {
      var nativeSelect = select.querySelector('select');
      var activeIndex = nativeSelect.options.selectedIndex;
      var selectedOption = nativeSelect.options[activeIndex];
      var buttonText = select.querySelector('.custom-select__text');
      var selectItems = select.querySelectorAll('.custom-select__item');
      buttonText.textContent = selectedOption.textContent;
      selectItems.forEach(function (item, index) {
        if (index === activeIndex - 1) {
          item.setAttribute('aria-selected', 'true');
          return;
        }
        item.setAttribute('aria-selected', 'false');
      });
      if (!nativeSelect.value) {
        select.classList.remove('not-empty');
        select.classList.remove('is-valid');
      }
    }
  }, {
    key: "_resetSelects",
    value: function _resetSelects(form) {
      var _this = this;
      var selects = form.querySelectorAll('[data-select]');
      selects.forEach(function (select) {
        _this._resetSelect(select);
      });
    }
  }, {
    key: "reset",
    value: function reset(form) {
      var _this2 = this;
      form.reset();
      form.querySelectorAll('.is-invalid').forEach(function (item) {
        return item.classList.remove('is-invalid');
      });
      form.querySelectorAll('.is-valid').forEach(function (item) {
        return item.classList.remove('is-valid');
      });
      form.querySelectorAll('.input-message').forEach(function (item) {
        return item.remove();
      });
      setTimeout(function () {
        _this2._resetSelects(form);
      });
    }
  }, {
    key: "initPhoneInput",
    value: function initPhoneInput(parent) {
      this._initPhoneInput(parent);
    }
  }, {
    key: "validateForm",
    value: function validateForm(form) {
      return this._validator.validateForm(form);
    }
  }, {
    key: "validateFormElement",
    value: function validateFormElement(item) {
      return this._validator.validateFormElement(item);
    }
  }, {
    key: "_onFormSubmit",
    value: function _onFormSubmit(event) {
      var _this3 = this;
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var result = this.validateForm(event.target);
      if (result === true && callback) {
        this._callbacks[callback].successCallback(event);
        if (this._callbacks[callback].reset) {
          setTimeout(function () {
            _this3.reset(event.target);
          }, this._callbacks[callback].resetTimeout ? this._callbacks[callback].resetTimeout : 500);
        }
        return;
      }
      if (result === false && callback) {
        this._callbacks[callback].errorCallback(event);
        return;
      }
      if (result === true) {
        event.target.submit();
      }
    }
  }, {
    key: "_onFormInput",
    value: function _onFormInput(item) {
      this.validateFormElement(item);
    }
  }, {
    key: "_initValidate",
    value: function _initValidate(parent) {
      var _this4 = this;
      var form = parent.querySelector('form');
      if (!form) {
        return;
      }
      var phoneParents = form.querySelectorAll('[data-validate-type="phone"]');
      phoneParents.forEach(function (item) {
        return _this4._initPhoneInput(item);
      });
      var callback = parent.dataset.callback;
      form.noValidate = true;
      form.addEventListener('submit', function (event) {
        _this4._onFormSubmit(event, callback);
      });
      form.addEventListener('input', function (event) {
        _this4._onFormInput(event.target);
      });
      form.addEventListener('reset', function (event) {
        _this4.reset(event.target);
      });
    }
  }, {
    key: "init",
    value: function init() {
      var _this5 = this;
      this._validateParent = document.querySelectorAll('[data-form-validate]');
      if (!this._validateParent.length) {
        return;
      }
      this._validateParent.forEach(function (parent) {
        return _this5._initValidate(parent);
      });
    }
  }]);
  return Form;
}();

/***/ }),

/***/ "./js/modules/form-validate/init-phone-input.js":
/*!******************************************************!*\
  !*** ./js/modules/form-validate/init-phone-input.js ***!
  \******************************************************/
/*! exports provided: initPhoneInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initPhoneInput", function() { return initPhoneInput; });
var baseCountryCode = '8';
var baseMatrix = '__________';
var phoneLength = baseCountryCode.length + baseMatrix.length;
var onPhoneInputInput = function onPhoneInputInput(e) {
  var matrix = "".concat(baseCountryCode).concat(baseMatrix);
  var def = matrix.replace(/\D/g, '');
  var i = 0;
  var val = e.target.value.replace(/\D/g, '');
  if (def.length >= val.length) {
    val = def;
  }
  e.target.value = matrix.replace(/./g, function (a) {
    if (/[_\d]/.test(a) && i < val.length) {
      return val.charAt(i++);
    } else if (i >= val.length) {
      return '';
    } else {
      return a;
    }
  });
};
var onPhoneInputFocus = function onPhoneInputFocus(_ref) {
  var target = _ref.target;
  if (!target.value) {
    target.value = baseCountryCode;
  }
  target.addEventListener('input', onPhoneInputInput);
  target.addEventListener('blur', onPhoneInputBlur);
  target.addEventListener('keydown', onPhoneInputKeydown);
  target.addEventListener('paste', onPhoneInputPaste);
  target.addEventListener('click', onPhoneInputClick);
};
var onPhoneInputClick = function onPhoneInputClick(e) {
  if (e.target.selectionStart < 4) {
    e.preventDefault();
    e.target.setSelectionRange(3, 3);
  }
};
var onPhoneInputPaste = function onPhoneInputPaste(e) {
  e.target.setSelectionRange(0, 0);
  if (!e.target.selectionStart) {
    setTimeout(function () {
      if (e.target.value.startsWith('+7')) {
        return;
      }
      if (e.target.value.startsWith('+8')) {
        e.target.value = "+7 ".concat(e.target.value.slice(3));
        return;
      }
      e.target.value = '';
    });
  }
};
var onPhoneInputKeydown = function onPhoneInputKeydown(e) {
  if (e.target.selectionStart < 4 && (e.keyCode === 37 || e.keyCode === 13)) {
    e.preventDefault();
    e.target.setSelectionRange(3, 3);
  }
};
var onPhoneInputBlur = function onPhoneInputBlur(_ref2) {
  var target = _ref2.target;
  if (target.value === baseCountryCode) {
    var parent = target.closest('[data-validate-type="phone"]');
    target.value = '';
    if (!parent.hasAttribute('data-required')) {
      parent.classList.remove('is-valid');
      parent.classList.remove('is-invalid');
      var parentMessage = parent.querySelector('.input-message');
      if (parentMessage) {
        parentMessage.remove();
      }
    }
    parent.classList.remove('not-empty');
    target.removeEventListener('input', onPhoneInputInput);
    target.removeEventListener('blur', onPhoneInputBlur);
    target.removeEventListener('keydown', onPhoneInputKeydown);
    target.removeEventListener('paste', onPhoneInputPaste);
    target.removeEventListener('click', onPhoneInputClick);
  }
};
var initPhoneInput = function initPhoneInput(parent) {
  var input = parent.querySelector('input');
  parent.dataset.phoneLength = phoneLength;
  input.addEventListener('focus', onPhoneInputFocus);
};

/***/ }),

/***/ "./js/modules/form-validate/matrix.js":
/*!********************************************!*\
  !*** ./js/modules/form-validate/matrix.js ***!
  \********************************************/
/*! exports provided: matrixReplace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matrixReplace", function() { return matrixReplace; });
var matrixReplace = function matrixReplace(item, matrix, RegEx) {
  if (!matrix) {
    // eslint-disable-next-line no-console
    console.error('При валидации по матрице обязательно указывать формат матрицы: data-matrix=""');
    item.value = '';
    return;
  }
  if (!RegEx) {
    // eslint-disable-next-line no-console
    console.error('При валидации по матрице обязательно указывать формат ограничений: data-matrix-limitations=""');
    item.value = '';
    return;
  }
  var def = matrix.replace(RegEx, '');
  var val = item.value.replace(RegEx, '');
  var i = 0;
  if (def.length >= val.length) {
    val = def;
  }
  item.value = matrix.replace(/./g, function (a) {
    if (/[_\^]/.test(a) && i < val.length) {
      return val.charAt(i++);
    } else if (i >= val.length) {
      return '';
    } else {
      return a;
    }
  });
};

/***/ }),

/***/ "./js/modules/form-validate/regular-expression.js":
/*!********************************************************!*\
  !*** ./js/modules/form-validate/regular-expression.js ***!
  \********************************************************/
/*! exports provided: getLimitationsRegEx, getMatrixLimitationsRegEx, getMailRegEx */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLimitationsRegEx", function() { return getLimitationsRegEx; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMatrixLimitationsRegEx", function() { return getMatrixLimitationsRegEx; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMailRegEx", function() { return getMailRegEx; });
var setLimitationError = function setLimitationError(limitation) {
  // eslint-disable-next-line no-console
  console.error("\u041F\u0435\u0440\u0435\u0434\u0430\u043D\u043D\u044B\u0439 \u0444\u043E\u0440\u043C\u0430\u0442 \u043E\u0433\u0440\u0430\u043D\u0438\u0447\u0435\u043D\u0438\u044F(data-limitation=\"".concat(limitation, "\") - \u043D\u0435 \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442\u0441\u044F. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u043E\u0441\u0442\u044C \u0432\u0432\u0435\u0434\u0451\u043D\u043D\u044B\u0445 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0439."));
};
var getLimitationsRegEx = function getLimitationsRegEx(limitation) {
  switch (limitation) {
    case 'digit':
      return /[^\d]/g;
    case 'name':
      return /[^a-zA-Zа-яёА-ЯЁ\-\s]/g;
    case 'letters':
      return /[^a-zA-Zа-яёА-ЯЁ\s]/g;
    case 'letters-and-digit':
      return /[^a-zA-Zа-яёА-ЯЁ\s\d]/g;
    case 'cyrillic':
      return /[^а-яёА-ЯЁ\s]/g;
    case 'latin':
      return /[^a-zA-Z\s]/g;
    default:
      return setLimitationError(limitation);
  }
};
var getMatrixLimitationsRegEx = function getMatrixLimitationsRegEx(matrix) {
  switch (matrix) {
    case 'digit':
      return /[^\d]/g;
    case 'name':
      return /[^\а-яё\А-ЯЁ\a-z\A-Z\-]]/g;
    case 'letters':
      return /[^\а-яё\А-ЯЁ\a-z\A-Z]/g;
    case 'letters-and-digit':
      return /[^\а-яё\А-ЯЁ\a-z\A-Z\d]/g;
    case 'cyrillic':
      return /[^\а-яё\А-ЯЁ]/g;
    case 'latin':
      return /[^\a-z\A-Z]/g;
    default:
      return false;
  }
};
var getMailRegEx = function getMailRegEx() {
  return /[a-zA-Zа-яёА-ЯЁ0-9]{1}([a-zA-Zа-яёА-ЯЁ0-9\-_\.]{1,})?@[a-zA-Zа-яёА-ЯЁ0-9\-]{1}([a-zA-Zа-яёА-ЯЁ0-9.\-]{1,})?[a-zA-Zа-яёА-ЯЁ0-9\-]{1}\.[a-zA-Zа-яёА-ЯЁ]{2,6}/;
};

/***/ }),

/***/ "./js/modules/form-validate/render-message.js":
/*!****************************************************!*\
  !*** ./js/modules/form-validate/render-message.js ***!
  \****************************************************/
/*! exports provided: Message */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Message", function() { return Message; });
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Message = /*#__PURE__*/function () {
  function Message() {
    _classCallCheck(this, Message);
    this._baseErrorText = 'Это поле является обязательным';
  }
  _createClass(Message, [{
    key: "_messageTemplate",
    value: function _messageTemplate(message, state) {
      var cssClass = state === 'valid' ? 'is-valid' : 'is-invalid';
      return "<span class=\"input-message ".concat(cssClass, "\">").concat(message, "</span>");
    }
  }, {
    key: "removeMessage",
    value: function removeMessage(parent) {
      var parentMessage = parent.querySelector('.input-message');
      if (parentMessage) {
        parentMessage.remove();
      }
    }
  }, {
    key: "renderMessage",
    value: function renderMessage(parent, message, state) {
      this.removeMessage(parent);
      parent.insertAdjacentHTML('beforeend', this._messageTemplate(message, state));
    }
  }]);
  return Message;
}();

/***/ }),

/***/ "./js/modules/form-validate/validator.js":
/*!***********************************************!*\
  !*** ./js/modules/form-validate/validator.js ***!
  \***********************************************/
/*! exports provided: Validator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Validator", function() { return Validator; });
/* harmony import */ var _regular_expression__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regular-expression */ "./js/modules/form-validate/regular-expression.js");
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matrix */ "./js/modules/form-validate/matrix.js");
/* harmony import */ var _render_message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./render-message */ "./js/modules/form-validate/render-message.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }



var Validator = /*#__PURE__*/function () {
  function Validator() {
    _classCallCheck(this, Validator);
    this._getLimitationsRegEx = _regular_expression__WEBPACK_IMPORTED_MODULE_0__["getLimitationsRegEx"];
    this._getMatrixLimitationsRegEx = _regular_expression__WEBPACK_IMPORTED_MODULE_0__["getMatrixLimitationsRegEx"];
    this._getMailRegEx = _regular_expression__WEBPACK_IMPORTED_MODULE_0__["getMailRegEx"];
    this._matrixReplace = _matrix__WEBPACK_IMPORTED_MODULE_1__["matrixReplace"];
    this._message = new _render_message__WEBPACK_IMPORTED_MODULE_2__["Message"]();
  }
  _createClass(Validator, [{
    key: "_renderMessage",
    value: function _renderMessage(trigger, parent, input) {
      if (!parent.hasAttribute('data-required') && !input.value) {
        return;
      }
      if (!trigger) {
        parent.classList.add('is-invalid');
        if (parent.hasAttribute('data-message-base') && !input.value) {
          this._message.renderMessage(parent, parent.dataset.messageBase, 'invalid');
        } else if (parent.hasAttribute('data-message-extra') && input.value) {
          this._message.renderMessage(parent, parent.dataset.messageExtra, 'invalid');
        } else if (!parent.hasAttribute('data-message-extra') && parent.hasAttribute('data-message-base') && input.value) {
          this._message.renderMessage(parent, parent.dataset.messageBase, 'invalid');
        } else {
          this._message.removeMessage(parent);
        }
      } else {
        if (parent.hasAttribute('data-message-success')) {
          this._message.renderMessage(parent, parent.dataset.messageSuccess, 'valid');
        } else {
          this._message.removeMessage(parent);
        }
      }
    }
  }, {
    key: "_setItemValidState",
    value: function _setItemValidState(parent, input) {
      if (!parent.hasAttribute('data-required') && !input.value) {
        return;
      }
      parent.classList.add('is-valid');
      parent.classList.remove('is-invalid');
      input.setAttribute('aria-invalid', 'false');
      this._message.removeMessage(parent);
    }
  }, {
    key: "_setItemInvalidState",
    value: function _setItemInvalidState(parent, input) {
      if (!parent.hasAttribute('data-required') && !input.value) {
        return;
      }
      parent.classList.remove('is-valid');
      input.setAttribute('aria-invalid', 'true');
    }
  }, {
    key: "_simpleLimitation",
    value: function _simpleLimitation(item, limitation) {
      item.value = item.value.replace(this._getLimitationsRegEx(limitation), '');
    }
  }, {
    key: "_matrixLimitation",
    value: function _matrixLimitation(item, matrix, limitation) {
      this._matrixReplace(item, matrix, limitation);
    }
  }, {
    key: "_validateTextInput",
    value: function _validateTextInput(parent, input) {
      var flag = true;
      if (input.value.length >= (+input.getAttribute('minlength') || 1)) {
        this._setItemValidState(parent, input);
      } else {
        this._setItemInvalidState(parent, input);
        flag = false;
      }
      return flag;
    }
  }, {
    key: "_validateMatrixInput",
    value: function _validateMatrixInput(parent, input) {
      var flag = true;
      if (input.value.length === input.closest('[data-matrix]').dataset.matrix.length) {
        this._setItemValidState(parent, input);
      } else {
        this._setItemInvalidState(parent, input);
        flag = false;
      }
      return flag;
    }
  }, {
    key: "_validateEmailInput",
    value: function _validateEmailInput(parent, input) {
      var flag = true;
      if (new RegExp(this._getMailRegEx(), '').test(input.value)) {
        this._setItemValidState(parent, input);
      } else {
        this._setItemInvalidState(parent, input);
        flag = false;
      }
      return flag;
    }
  }, {
    key: "_validatePhoneInput",
    value: function _validatePhoneInput(parent, input) {
      var flag = true;
      if (input.value.length >= +parent.dataset.phoneLength) {
        this._setItemValidState(parent, input);
      } else {
        this._setItemInvalidState(parent, input);
        flag = false;
      }
      return flag;
    }
  }, {
    key: "_validateCheckbox",
    value: function _validateCheckbox(parent, input) {
      var flag = true;
      if (input.checked) {
        this._setItemValidState(parent, input);
      } else {
        this._setItemInvalidState(parent, input);
        flag = false;
      }
      return flag;
    }
  }, {
    key: "_findSelectedOption",
    value: function _findSelectedOption(options) {
      var flag = false;
      options.forEach(function (option) {
        if (option.value && option.selected) {
          flag = true;
        }
      });
      return flag;
    }
  }, {
    key: "_validateSelect",
    value: function _validateSelect(parent, input) {
      var options = input.querySelectorAll('option');
      var customSelectText = parent.querySelector('.custom-select__text');
      input.setAttribute('aria-invalid', 'false');
      var flag = true;
      if (this._findSelectedOption(options)) {
        this._setItemValidState(parent, input);
      } else {
        this._setItemInvalidState(parent, input);
        parent.classList.remove('not-empty');
        customSelectText.innerHTML = '';
        flag = false;
      }
      return flag;
    }
  }, {
    key: "_returnCheckedElements",
    value: function _returnCheckedElements(inputs) {
      var flag = false;
      inputs.forEach(function (input) {
        if (input.checked) {
          flag = true;
        }
      });
      return flag;
    }
  }, {
    key: "_removeGroupAria",
    value: function _removeGroupAria(inputs) {
      inputs.forEach(function (input) {
        if (!input.checked) {
          input.removeAttribute('aria-required');
          input.removeAttribute('aria-invalid');
        } else {
          input.setAttribute('aria-required', true);
          input.setAttribute('aria-invalid', false);
        }
      });
    }
  }, {
    key: "_setGroupAria",
    value: function _setGroupAria(inputs) {
      inputs.forEach(function (input) {
        input.setAttribute('aria-required', true);
        input.setAttribute('aria-invalid', true);
      });
    }
  }, {
    key: "_validateToggleGroup",
    value: function _validateToggleGroup(parent) {
      var formElements = parent.querySelectorAll('input');
      var flag = true;
      if (this._returnCheckedElements(formElements)) {
        this._removeGroupAria(formElements);
        parent.classList.remove('is-invalid');
        parent.classList.add('is-valid');
        this._message.removeMessage(parent);
      } else {
        this._setGroupAria(formElements);
        parent.classList.remove('is-valid');
        flag = false;
      }
      return flag;
    }
  }, {
    key: "_customExample",
    value: function _customExample(parent, input) {
      var flag = true;
      if (!input.value.length) {
        parent.dataset.messageBase = 'Поле обязательно к заполнению';
        this._setItemInvalidState(parent, input);
        flag = false;
      } else if (input.value.length < input.minLength) {
        parent.dataset.messageBase = "\u041E\u0441\u0442\u0430\u043B\u043E\u0441\u044C \u0432\u0432\u0435\u0441\u0442\u0438 \u0435\u0449\u0451 ".concat(input.minLength - input.value.length, " \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432");
        this._setItemInvalidState(parent, input);
        flag = false;
      } else if (input.value.length > input.minLength) {
        parent.dataset.messageBase = "\u0412\u044B \u0432\u0432\u0435\u043B\u0438 ".concat(input.value.length - input.minLength, " \u043B\u0438\u0448\u043D\u0438\u0445 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432");
        this._setItemInvalidState(parent, input);
        flag = false;
      } else {
        parent.dataset.messageSuccess = 'Поле заполнено корректно';
        this._setItemValidState(parent, input);
        flag = true;
      }
      return flag;
    }
  }, {
    key: "_validateFile",
    value: function _validateFile(parent, input) {
      var flag = true;
      var sizeTest = parent.dataset.maxSize && input.files[0] ? input.files[0].size < +parent.dataset.maxSize : true;
      if (input.value && sizeTest) {
        this._setItemValidState(parent, input);
      } else {
        this._setItemInvalidState(parent, input);
        flag = false;
      }
      return flag;
    }
  }, {
    key: "_validateInput",
    value: function _validateInput(type, parent, input) {
      switch (type) {
        case 'text':
          return this._validateTextInput(parent, input);
        case 'matrix':
          return this._validateMatrixInput(parent, input);
        case 'email':
          return this._validateEmailInput(parent, input);
        case 'phone':
          return this._validatePhoneInput(parent, input);
        case 'checkbox':
          return this._validateCheckbox(parent, input);
        case 'select':
          return this._validateSelect(parent, input);
        case 'toggle-group':
          return this._validateToggleGroup(parent, input);
        case 'file':
          return this._validateFile(parent, input);
        case 'custom-example':
          return this._customExample(parent, input);
        default:
          return false;
      }
    }
  }, {
    key: "validateFormElement",
    value: function validateFormElement(formElement) {
      var fullValidate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var parent = formElement.closest('[data-validate-type]');
      if (!parent) {
        return;
      }
      if (!parent.hasAttribute('data-required')) {
        var removeElement = parent.querySelector('input') || parent.querySelector('select') || parent.querySelector('textarea');
        if (!removeElement.value) {
          parent.classList.remove('is-valid');
          parent.classList.remove('is-invalid');
        }
      }
      var onInputValidate = parent.hasAttribute('data-on-input-validate');
      if (parent.hasAttribute('data-limitation')) {
        this._simpleLimitation(formElement, parent.dataset.limitation);
      }
      if (parent.dataset.validateType === 'matrix') {
        this._matrixLimitation(formElement, parent.dataset.matrix, this._getMatrixLimitationsRegEx(parent.dataset.matrixLimitation));
      }
      var isValid = this._validateInput(parent.dataset.validateType, parent, formElement);
      if (onInputValidate || fullValidate) {
        this._renderMessage(isValid, parent, formElement);
      }
    }
  }, {
    key: "_fullValidate",
    value: function _fullValidate(items) {
      var _this = this;
      var result = true;
      items.forEach(function (item) {
        var formElement = item.querySelector('input') || item.querySelector('select') || item.querySelector('textarea');
        _this.validateFormElement(formElement, true);
        if (item.classList.contains('is-invalid')) {
          result = false;
        }
      });
      return result;
    }
  }, {
    key: "validateForm",
    value: function validateForm(form) {
      var validateItems = form.querySelectorAll('[data-validate-type]');
      var result = this._fullValidate(validateItems);
      return result;
    }
  }]);
  return Validator;
}();

/***/ }),

/***/ "./js/modules/menu/burger.js":
/*!***********************************!*\
  !*** ./js/modules/menu/burger.js ***!
  \***********************************/
/*! exports provided: Burger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Burger", function() { return Burger; });
/* harmony import */ var _scroll_lock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scroll-lock */ "./js/modules/menu/scroll-lock.js");
/* harmony import */ var _focus_lock__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./focus-lock */ "./js/modules/menu/focus-lock.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }


var Burger = /*#__PURE__*/function () {
  function Burger() {
    _classCallCheck(this, Burger);
    this._header = document.querySelector('[data-header]');
    this._burger = document.querySelector('[data-burger]');
    this._scrollLock = new _scroll_lock__WEBPACK_IMPORTED_MODULE_0__["ScrollLock"]();
    this._focusLock = new _focus_lock__WEBPACK_IMPORTED_MODULE_1__["FocusLock"]();
    this._isMenuOpen = false;
    this._onBurgerClick = this._onBurgerClick.bind(this);
    this._onDocumentKeydown = this._onDocumentKeydown.bind(this);
    this._onDocumentClick = this._onDocumentClick.bind(this);
  }
  _createClass(Burger, [{
    key: "init",
    value: function init() {
      if (!this._burger) {
        return;
      }
      this._burger.addEventListener('click', this._onBurgerClick);
    }
  }, {
    key: "_openMenu",
    value: function _openMenu() {
      this._isMenuOpen = true;
      this._header.classList.add('is-open');
      this._scrollLock.disableScrolling();
      document.addEventListener('keydown', this._onDocumentKeydown);
      document.addEventListener('click', this._onDocumentClick);
      this._focusLock.lock('[data-header]');
      if (window.ls) {
        window.ls.stop();
      }
    }
  }, {
    key: "_closeMenu",
    value: function _closeMenu() {
      this._isMenuOpen = false;
      this._header.classList.remove('is-open');
      this._scrollLock.enableScrolling();
      this._focusLock.unlock('[data-header]');
      document.removeEventListener('keydown', this._onDocumentKeydown);
      document.removeEventListener('click', this._onDocumentClick);
      if (window.ls) {
        window.ls.start();
      }
    }
  }, {
    key: "_onBurgerClick",
    value: function _onBurgerClick() {
      if (this._isMenuOpen) {
        this._closeMenu();
      } else {
        this._openMenu();
      }
    }
  }, {
    key: "_onDocumentKeydown",
    value: function _onDocumentKeydown(evt) {
      if (evt.key === 'Escape') {
        this._closeMenu();
      }
    }
  }, {
    key: "_onDocumentClick",
    value: function _onDocumentClick(evt) {
      if (evt.target.hasAttribute('data-close-menu')) {
        this._closeMenu();
      }
    }
  }]);
  return Burger;
}();

/***/ }),

/***/ "./js/modules/menu/focus-lock.js":
/*!***************************************!*\
  !*** ./js/modules/menu/focus-lock.js ***!
  \***************************************/
/*! exports provided: FocusLock */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FocusLock", function() { return FocusLock; });
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var SELECTORS = ['a[href]', 'area[href]', 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', 'select:not([disabled]):not([aria-hidden])', 'textarea:not([disabled]):not([aria-hidden])', 'button:not([disabled]):not([aria-hidden])', 'iframe', 'object', 'embed', '[contenteditable]', '[tabindex]:not([tabindex^="-"])'];
var FocusLock = /*#__PURE__*/function () {
  function FocusLock() {
    _classCallCheck(this, FocusLock);
    this._lockedSelector = null;
    this._focusableElements = null;
    this._endElement = null;
    this._selectors = SELECTORS;
    this._documentKeydownHandler = this._documentKeydownHandler.bind(this);
  }
  _createClass(FocusLock, [{
    key: "_documentKeydownHandler",
    value: function _documentKeydownHandler(evt) {
      var activeElement = document.activeElement;
      if (evt.key === 'Tab') {
        if (!this._focusableElements.length) {
          evt.preventDefault();
          activeElement.blur();
          return;
        }
        if (this._focusableElements.length === 1) {
          evt.preventDefault();
          this._focusableElements[0].focus();
          return;
        }
        if (this._focusableElements.length > 1 && !activeElement.closest(this._lockedSelector)) {
          evt.preventDefault();
          this._focusableElements[0].focus();
          return;
        }
      }
      if (evt.key === 'Tab' && !evt.shiftKey && activeElement === this._focusableElements[this._focusableElements.length - 1]) {
        evt.preventDefault();
        this._focusableElements[0].focus();
      }
      if (evt.key === 'Tab' && evt.shiftKey && activeElement === this._focusableElements[0]) {
        evt.preventDefault();
        this._focusableElements[this._focusableElements.length - 1].focus();
      }
    }
  }, {
    key: "lock",
    value: function lock(lockedSelector) {
      var startFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.unlock();
      this._lockedSelector = lockedSelector;
      var lockedElement = document.querySelector(this._lockedSelector);
      if (!lockedElement) {
        return;
      }
      this._focusableElements = lockedElement.querySelectorAll(this._selectors);
      this._endElement = document.activeElement;
      var startElement = lockedElement.querySelector('[data-focus]') || this._focusableElements[0];
      if (this._endElement) {
        this._endElement.blur();
      }
      if (startElement && startFocus) {
        startElement.focus();
      }
      document.addEventListener('keydown', this._documentKeydownHandler);
    }
  }, {
    key: "unlock",
    value: function unlock() {
      var returnFocus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (this._endElement && returnFocus) {
        this._endElement.focus();
      }
      this._lockedSelector = null;
      this._focusableElements = null;
      this._endElement = null;
      document.removeEventListener('keydown', this._documentKeydownHandler);
    }
  }]);
  return FocusLock;
}();
window.focusLock = new FocusLock();

/***/ }),

/***/ "./js/modules/menu/index.js":
/*!**********************************!*\
  !*** ./js/modules/menu/index.js ***!
  \**********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _vendor_locomotive_scroll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../vendor/locomotive-scroll */ "./js/vendor/locomotive-scroll.js");
/* harmony import */ var _burger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./burger */ "./js/modules/menu/burger.js");
/* harmony import */ var _sticky_header__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sticky-header */ "./js/modules/menu/sticky-header.js");
/* harmony import */ var _init_locomotive_scroll__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init-locomotive-scroll */ "./js/modules/menu/init-locomotive-scroll.js");




window.addEventListener('DOMContentLoaded', function () {
  Object(_init_locomotive_scroll__WEBPACK_IMPORTED_MODULE_3__["initLocomotiveScroll"])();
  window.addEventListener('load', function () {
    var burger = new _burger__WEBPACK_IMPORTED_MODULE_1__["Burger"]();
    burger.init();
    var stickyHeader = new _sticky_header__WEBPACK_IMPORTED_MODULE_2__["StickyHeader"]();
    stickyHeader.init();
  });
});

/***/ }),

/***/ "./js/modules/menu/init-locomotive-scroll.js":
/*!***************************************************!*\
  !*** ./js/modules/menu/init-locomotive-scroll.js ***!
  \***************************************************/
/*! exports provided: initLocomotiveScroll */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initLocomotiveScroll", function() { return initLocomotiveScroll; });
var locomotiveContainer = document.querySelector('[data-scroll-container]');
var initLocomotive = function initLocomotive() {
  var options = {
    el: locomotiveContainer,
    smooth: true,
    getDirection: true,
    multiplier: 0.7,
    touchMultiplier: 5,
    lerp: 0.1,
    mobile: {
      smooth: true
    },
    tablet: {
      smooth: true
    }
  };
  window.ls = new window.LocomotiveScroll(options);
  window.addEventListener('resize', function () {
    setTimeout(function () {
      window.ls.update();
    }, 500);
  });
};
var initLocomotiveScroll = function initLocomotiveScroll() {
  if (!locomotiveContainer) {
    return;
  }
  initLocomotive();
};

/***/ }),

/***/ "./js/modules/menu/ios-checker.js":
/*!****************************************!*\
  !*** ./js/modules/menu/ios-checker.js ***!
  \****************************************/
/*! exports provided: iosChecker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iosChecker", function() { return iosChecker; });
var iosChecker = function iosChecker() {
  return ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(navigator.platform)
  // iPad on iOS 13 detection
  || navigator.userAgent.includes('Mac') && 'ontouchend' in document;
};

/***/ }),

/***/ "./js/modules/menu/scroll-lock.js":
/*!****************************************!*\
  !*** ./js/modules/menu/scroll-lock.js ***!
  \****************************************/
/*! exports provided: ScrollLock */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScrollLock", function() { return ScrollLock; });
/* harmony import */ var _ios_checker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ios-checker */ "./js/modules/menu/ios-checker.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

var ScrollLock = /*#__PURE__*/function () {
  function ScrollLock() {
    _classCallCheck(this, ScrollLock);
    this._iosChecker = _ios_checker__WEBPACK_IMPORTED_MODULE_0__["iosChecker"];
    this._lockClass = this._iosChecker() ? 'scroll-lock-ios' : 'scroll-lock';
    this._scrollTop = null;
    this._fixedBlockElements = document.querySelectorAll('[data-fix-block]');
  }
  _createClass(ScrollLock, [{
    key: "_getScrollbarWidth",
    value: function _getScrollbarWidth() {
      return window.innerWidth - document.documentElement.clientWidth;
    }
  }, {
    key: "_getBodyScrollTop",
    value: function _getBodyScrollTop() {
      return self.pageYOffset || document.documentElement && document.documentElement.ScrollTop || document.body && document.body.scrollTop;
    }
  }, {
    key: "disableScrolling",
    value: function disableScrolling() {
      var _this = this;
      this._scrollTop = document.body.dataset.scroll = document.body.dataset.scroll ? document.body.dataset.scroll : this._getBodyScrollTop();
      if (this._getScrollbarWidth()) {
        document.body.style.paddingRight = "".concat(this._getScrollbarWidth(), "px");
        this._fixedBlockElements.forEach(function (block) {
          block.style.paddingRight = "".concat(_this._getScrollbarWidth(), "px");
        });
      }
      document.body.style.top = "-".concat(this._scrollTop, "px");
      document.body.classList.add(this._lockClass);
    }
  }, {
    key: "enableScrolling",
    value: function enableScrolling() {
      document.body.classList.remove(this._lockClass);
      window.scrollTo(0, +document.body.dataset.scroll);
      document.body.style.paddingRight = null;
      document.body.style.top = null;
      this._fixedBlockElements.forEach(function (block) {
        block.style.paddingRight = null;
      });
      document.body.removeAttribute('data-scroll');
      this._scrollTop = null;
    }
  }]);
  return ScrollLock;
}();
window.scrollLock = new ScrollLock();

/***/ }),

/***/ "./js/modules/menu/sticky-header.js":
/*!******************************************!*\
  !*** ./js/modules/menu/sticky-header.js ***!
  \******************************************/
/*! exports provided: StickyHeader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StickyHeader", function() { return StickyHeader; });
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var StickyHeader = /*#__PURE__*/function () {
  function StickyHeader() {
    _classCallCheck(this, StickyHeader);
    this._stickyHeader = document.querySelector('[data-header="sticky"]');
    this._headerHeight = this._stickyHeader ? this._stickyHeader.offsetHeight : '';
    this._hidePoint = this._stickyHeader ? +this._stickyHeader.dataset.hidePoint : 0;
    this._hidePoint = this._hidePoint ? this._hidePoint : 0;
    this._themeItems = document.querySelectorAll('[data-header-theme-class]');
    this._activeTheme = null;
    this._scrollY = null;
    this._prevScrollY = null;
    this._isHidden = false;
    this._isDisableScrolling = false;
    this._onWindowScroll = this._onWindowScroll.bind(this);
    this._onLocomotiveScroll = this._onLocomotiveScroll.bind(this);
  }
  _createClass(StickyHeader, [{
    key: "init",
    value: function init() {
      if (!this._stickyHeader) {
        return;
      }
      this._checkTheme();
      if (window.ls) {
        window.ls.on('scroll', this._onLocomotiveScroll);
        return;
      }
      window.addEventListener('scroll', this._onWindowScroll);
    }
  }, {
    key: "_hideHeader",
    value: function _hideHeader() {
      if (!this._isHidden) {
        this._isHidden = true;
        this._stickyHeader.classList.add('is-hidden');
      }
    }
  }, {
    key: "_showHeader",
    value: function _showHeader() {
      if (this._isHidden) {
        this._isHidden = false;
        this._stickyHeader.classList.remove('is-hidden');
      }
    }
  }, {
    key: "_checkScrollDirection",
    value: function _checkScrollDirection() {
      if (this._scrollY > this._prevScrollY) {
        return 'down';
      }
      return 'up';
    }
  }, {
    key: "_onLocomotiveScroll",
    value: function _onLocomotiveScroll(evt) {
      this._checkTheme();
      if (evt.direction === 'down' && evt.delta.y > this._hidePoint) {
        this._hideHeader();
      }
      if (evt.direction === 'up' || evt.delta.y <= this._hidePoint) {
        this._showHeader();
      }
    }
  }, {
    key: "_onWindowScroll",
    value: function _onWindowScroll() {
      this._scrollY = document.documentElement.scrollTop;
      this._checkTheme();
      if (this._checkScrollDirection() === 'down' && this._scrollY > this._hidePoint) {
        this._hideHeader();
      }
      if (this._checkScrollDirection() === 'up' || this._scrollY <= this._hidePoint) {
        this._showHeader();
      }
      this._prevScrollY = this._scrollY;
    }
  }, {
    key: "_checkTheme",
    value: function _checkTheme() {
      var _this = this;
      this._themeItems.forEach(function (item) {
        if (item.getBoundingClientRect().top <= 0 && item.getBoundingClientRect().height + item.getBoundingClientRect().top > 0) {
          if (_this._activeTheme === item.dataset.headerThemeClass) {
            return;
          }
          _this._stickyHeader.classList.remove(_this._activeTheme);
          _this._activeTheme = item.dataset.headerThemeClass;
          _this._stickyHeader.classList.add(_this._activeTheme);
        }
      });
    }
  }]);
  return StickyHeader;
}();

/***/ }),

/***/ "./js/utils/ios-checker.js":
/*!*********************************!*\
  !*** ./js/utils/ios-checker.js ***!
  \*********************************/
/*! exports provided: iosChecker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iosChecker", function() { return iosChecker; });
var iosChecker = function iosChecker() {
  return ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(navigator.platform)
  // iPad on iOS 13 detection
  || navigator.userAgent.includes('Mac') && 'ontouchend' in document;
};

/***/ }),

/***/ "./js/utils/ios-vh-fix.js":
/*!********************************!*\
  !*** ./js/utils/ios-vh-fix.js ***!
  \********************************/
/*! exports provided: iosVhFix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iosVhFix", function() { return iosVhFix; });
/* harmony import */ var _ios_checker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ios-checker */ "./js/utils/ios-checker.js");

var iosVhFix = function iosVhFix() {
  if (!(!!window.MSInputMethodContext && !!document.documentMode)) {
    if (Object(_ios_checker__WEBPACK_IMPORTED_MODULE_0__["iosChecker"])()) {
      var vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty('--vh', "".concat(vh, "px"));
      window.addEventListener('resize', function () {
        vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', "".concat(vh, "px"));
      });
    }
  }
};


/***/ }),

/***/ "./js/vendor/locomotive-scroll.js":
/*!****************************************!*\
  !*** ./js/vendor/locomotive-scroll.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, module) {var _this10 = undefined;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
/* locomotive-scroll v4.1.3 | MIT License | https://github.com/locomotivemtl/locomotive-scroll */

var LocomotiveScroll = function LocomotiveScroll() {
  (function (global, factory) {
    (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && __webpack_require__(/*! !webpack amd options */ "../node_modules/webpack/buildin/amd-options.js") ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.LocomotiveScroll = factory());
  })(_this10, function () {
    'use strict';

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function (key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived),
          result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null) break;
      }
      return object;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get(target, property, receiver) {
          var base = _superPropBase(target, property);
          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.get) {
            return desc.get.call(receiver);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
    }
    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var defaults = {
      el: document,
      name: 'scroll',
      offset: [0, 0],
      repeat: false,
      smooth: false,
      initPosition: {
        x: 0,
        y: 0
      },
      direction: 'vertical',
      gestureDirection: 'vertical',
      reloadOnContextChange: false,
      lerp: 0.1,
      "class": 'is-inview',
      scrollbarContainer: false,
      scrollbarClass: 'c-scrollbar',
      scrollingClass: 'has-scroll-scrolling',
      draggingClass: 'has-scroll-dragging',
      smoothClass: 'has-scroll-smooth',
      initClass: 'has-scroll-init',
      getSpeed: false,
      getDirection: false,
      scrollFromAnywhere: false,
      multiplier: 1,
      firefoxMultiplier: 50,
      touchMultiplier: 2,
      resetNativeScroll: true,
      tablet: {
        smooth: false,
        direction: 'vertical',
        gestureDirection: 'vertical',
        breakpoint: 1024
      },
      smartphone: {
        smooth: false,
        direction: 'vertical',
        gestureDirection: 'vertical'
      }
    };
    var _default = /*#__PURE__*/function () {
      function _default() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        _classCallCheck(this, _default);
        Object.assign(this, defaults, options);
        this.smartphone = defaults.smartphone;
        if (options.smartphone) Object.assign(this.smartphone, options.smartphone);
        this.tablet = defaults.tablet;
        if (options.tablet) Object.assign(this.tablet, options.tablet);
        this.namespace = 'locomotive';
        this.html = document.documentElement;
        this.windowHeight = window.innerHeight;
        this.windowWidth = window.innerWidth;
        this.windowMiddle = {
          x: this.windowWidth / 2,
          y: this.windowHeight / 2
        };
        this.els = {};
        this.currentElements = {};
        this.listeners = {};
        this.hasScrollTicking = false;
        this.hasCallEventSet = false;
        this.checkScroll = this.checkScroll.bind(this);
        this.checkResize = this.checkResize.bind(this);
        this.checkEvent = this.checkEvent.bind(this);
        this.instance = {
          scroll: {
            x: 0,
            y: 0
          },
          limit: {
            x: this.html.offsetWidth,
            y: this.html.offsetHeight
          },
          currentElements: this.currentElements
        };
        if (this.isMobile) {
          if (this.isTablet) {
            this.context = 'tablet';
          } else {
            this.context = 'smartphone';
          }
        } else {
          this.context = 'desktop';
        }
        if (this.isMobile) this.direction = this[this.context].direction;
        if (this.direction === 'horizontal') {
          this.directionAxis = 'x';
        } else {
          this.directionAxis = 'y';
        }
        if (this.getDirection) {
          this.instance.direction = null;
        }
        if (this.getDirection) {
          this.instance.speed = 0;
        }
        this.html.classList.add(this.initClass);
        window.addEventListener('resize', this.checkResize, false);
      }
      _createClass(_default, [{
        key: "init",
        value: function init() {
          this.initEvents();
        }
      }, {
        key: "checkScroll",
        value: function checkScroll() {
          this.dispatchScroll();
        }
      }, {
        key: "checkResize",
        value: function checkResize() {
          var _this = this;
          if (!this.resizeTick) {
            this.resizeTick = true;
            requestAnimationFrame(function () {
              _this.resize();
              _this.resizeTick = false;
            });
          }
        }
      }, {
        key: "resize",
        value: function resize() {}
      }, {
        key: "checkContext",
        value: function checkContext() {
          if (!this.reloadOnContextChange) return;
          this.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1 || this.windowWidth < this.tablet.breakpoint;
          this.isTablet = this.isMobile && this.windowWidth >= this.tablet.breakpoint;
          var oldContext = this.context;
          if (this.isMobile) {
            if (this.isTablet) {
              this.context = 'tablet';
            } else {
              this.context = 'smartphone';
            }
          } else {
            this.context = 'desktop';
          }
          if (oldContext != this.context) {
            var oldSmooth = oldContext == 'desktop' ? this.smooth : this[oldContext].smooth;
            var newSmooth = this.context == 'desktop' ? this.smooth : this[this.context].smooth;
            if (oldSmooth != newSmooth) window.location.reload();
          }
        }
      }, {
        key: "initEvents",
        value: function initEvents() {
          var _this2 = this;
          this.scrollToEls = this.el.querySelectorAll("[data-".concat(this.name, "-to]"));
          this.setScrollTo = this.setScrollTo.bind(this);
          this.scrollToEls.forEach(function (el) {
            el.addEventListener('click', _this2.setScrollTo, false);
          });
        }
      }, {
        key: "setScrollTo",
        value: function setScrollTo(event) {
          event.preventDefault();
          this.scrollTo(event.currentTarget.getAttribute("data-".concat(this.name, "-href")) || event.currentTarget.getAttribute('href'), {
            offset: event.currentTarget.getAttribute("data-".concat(this.name, "-offset"))
          });
        }
      }, {
        key: "addElements",
        value: function addElements() {}
      }, {
        key: "detectElements",
        value: function detectElements(hasCallEventSet) {
          var _this3 = this;
          var scrollTop = this.instance.scroll.y;
          var scrollBottom = scrollTop + this.windowHeight;
          var scrollLeft = this.instance.scroll.x;
          var scrollRight = scrollLeft + this.windowWidth;
          Object.entries(this.els).forEach(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
              i = _ref2[0],
              el = _ref2[1];
            if (el && (!el.inView || hasCallEventSet)) {
              if (_this3.direction === 'horizontal') {
                if (scrollRight >= el.left && scrollLeft < el.right) {
                  _this3.setInView(el, i);
                }
              } else {
                if (scrollBottom >= el.top && scrollTop < el.bottom) {
                  _this3.setInView(el, i);
                }
              }
            }
            if (el && el.inView) {
              if (_this3.direction === 'horizontal') {
                var width = el.right - el.left;
                el.progress = (_this3.instance.scroll.x - (el.left - _this3.windowWidth)) / (width + _this3.windowWidth);
                if (scrollRight < el.left || scrollLeft > el.right) {
                  _this3.setOutOfView(el, i);
                }
              } else {
                var height = el.bottom - el.top;
                el.progress = (_this3.instance.scroll.y - (el.top - _this3.windowHeight)) / (height + _this3.windowHeight);
                if (scrollBottom < el.top || scrollTop > el.bottom) {
                  _this3.setOutOfView(el, i);
                }
              }
            }
          }); // this.els = this.els.filter((current, i) => {
          //     return current !== null;
          // });

          this.hasScrollTicking = false;
        }
      }, {
        key: "setInView",
        value: function setInView(current, i) {
          this.els[i].inView = true;
          current.el.classList.add(current["class"]);
          this.currentElements[i] = current;
          if (current.call && this.hasCallEventSet) {
            this.dispatchCall(current, 'enter');
            if (!current.repeat) {
              this.els[i].call = false;
            }
          } // if (!current.repeat && !current.speed && !current.sticky) {
          //     if (!current.call || current.call && this.hasCallEventSet) {
          //        this.els[i] = null
          //     }
          // }
        }
      }, {
        key: "setOutOfView",
        value: function setOutOfView(current, i) {
          var _this4 = this;

          // if (current.repeat || current.speed !== undefined) {
          this.els[i].inView = false; // }

          Object.keys(this.currentElements).forEach(function (el) {
            el === i && delete _this4.currentElements[el];
          });
          if (current.call && this.hasCallEventSet) {
            this.dispatchCall(current, 'exit');
          }
          if (current.repeat) {
            current.el.classList.remove(current["class"]);
          }
        }
      }, {
        key: "dispatchCall",
        value: function dispatchCall(current, way) {
          this.callWay = way;
          this.callValue = current.call.split(',').map(function (item) {
            return item.trim();
          });
          this.callObj = current;
          if (this.callValue.length == 1) this.callValue = this.callValue[0];
          var callEvent = new Event(this.namespace + 'call');
          this.el.dispatchEvent(callEvent);
        }
      }, {
        key: "dispatchScroll",
        value: function dispatchScroll() {
          var scrollEvent = new Event(this.namespace + 'scroll');
          this.el.dispatchEvent(scrollEvent);
        }
      }, {
        key: "setEvents",
        value: function setEvents(event, func) {
          if (!this.listeners[event]) {
            this.listeners[event] = [];
          }
          var list = this.listeners[event];
          list.push(func);
          if (list.length === 1) {
            this.el.addEventListener(this.namespace + event, this.checkEvent, false);
          }
          if (event === 'call') {
            this.hasCallEventSet = true;
            this.detectElements(true);
          }
        }
      }, {
        key: "unsetEvents",
        value: function unsetEvents(event, func) {
          if (!this.listeners[event]) return;
          var list = this.listeners[event];
          var index = list.indexOf(func);
          if (index < 0) return;
          list.splice(index, 1);
          if (list.index === 0) {
            this.el.removeEventListener(this.namespace + event, this.checkEvent, false);
          }
        }
      }, {
        key: "checkEvent",
        value: function checkEvent(event) {
          var _this5 = this;
          var name = event.type.replace(this.namespace, '');
          var list = this.listeners[name];
          if (!list || list.length === 0) return;
          list.forEach(function (func) {
            switch (name) {
              case 'scroll':
                return func(_this5.instance);
              case 'call':
                return func(_this5.callValue, _this5.callWay, _this5.callObj);
              default:
                return func();
            }
          });
        }
      }, {
        key: "startScroll",
        value: function startScroll() {}
      }, {
        key: "stopScroll",
        value: function stopScroll() {}
      }, {
        key: "setScroll",
        value: function setScroll(x, y) {
          this.instance.scroll = {
            x: 0,
            y: 0
          };
        }
      }, {
        key: "destroy",
        value: function destroy() {
          var _this6 = this;
          window.removeEventListener('resize', this.checkResize, false);
          Object.keys(this.listeners).forEach(function (event) {
            _this6.el.removeEventListener(_this6.namespace + event, _this6.checkEvent, false);
          });
          this.listeners = {};
          this.scrollToEls.forEach(function (el) {
            el.removeEventListener('click', _this6.setScrollTo, false);
          });
          this.html.classList.remove(this.initClass);
        }
      }]);
      return _default;
    }();
    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
    function createCommonjsModule(fn, module) {
      return module = {
        exports: {}
      }, fn(module, module.exports), module.exports;
    }
    var smoothscroll = createCommonjsModule(function (module, exports) {
      /* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */
      (function () {
        // polyfill
        function polyfill() {
          // aliases
          var w = window;
          var d = document;

          // return if scroll behavior is supported and polyfill is not forced
          if ('scrollBehavior' in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {
            return;
          }

          // globals
          var Element = w.HTMLElement || w.Element;
          var SCROLL_TIME = 468;

          // object gathering original scroll methods
          var original = {
            scroll: w.scroll || w.scrollTo,
            scrollBy: w.scrollBy,
            elementScroll: Element.prototype.scroll || scrollElement,
            scrollIntoView: Element.prototype.scrollIntoView
          };

          // define timing method
          var now = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;

          /**
           * indicates if a the current browser is made by Microsoft
           * @method isMicrosoftBrowser
           * @param {String} userAgent
           * @returns {Boolean}
           */
          function isMicrosoftBrowser(userAgent) {
            var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];
            return new RegExp(userAgentPatterns.join('|')).test(userAgent);
          }

          /*
          * IE has rounding bug rounding down clientHeight and clientWidth and
          * rounding up scrollHeight and scrollWidth causing false positives
          * on hasScrollableSpace
          */
          var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;

          /**
           * changes scroll position inside an element
           * @method scrollElement
           * @param {Number} x
           * @param {Number} y
           * @returns {undefined}
           */
          function scrollElement(x, y) {
            this.scrollLeft = x;
            this.scrollTop = y;
          }

          /**
           * returns result of applying ease math function to a number
           * @method ease
           * @param {Number} k
           * @returns {Number}
           */
          function ease(k) {
            return 0.5 * (1 - Math.cos(Math.PI * k));
          }

          /**
           * indicates if a smooth behavior should be applied
           * @method shouldBailOut
           * @param {Number|Object} firstArg
           * @returns {Boolean}
           */
          function shouldBailOut(firstArg) {
            if (firstArg === null || _typeof(firstArg) !== 'object' || firstArg.behavior === undefined || firstArg.behavior === 'auto' || firstArg.behavior === 'instant') {
              // first argument is not an object/null
              // or behavior is auto, instant or undefined
              return true;
            }
            if (_typeof(firstArg) === 'object' && firstArg.behavior === 'smooth') {
              // first argument is an object and behavior is smooth
              return false;
            }

            // throw error when behavior is not supported
            throw new TypeError('behavior member of ScrollOptions ' + firstArg.behavior + ' is not a valid value for enumeration ScrollBehavior.');
          }

          /**
           * indicates if an element has scrollable space in the provided axis
           * @method hasScrollableSpace
           * @param {Node} el
           * @param {String} axis
           * @returns {Boolean}
           */
          function hasScrollableSpace(el, axis) {
            if (axis === 'Y') {
              return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;
            }
            if (axis === 'X') {
              return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;
            }
          }

          /**
           * indicates if an element has a scrollable overflow property in the axis
           * @method canOverflow
           * @param {Node} el
           * @param {String} axis
           * @returns {Boolean}
           */
          function canOverflow(el, axis) {
            var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];
            return overflowValue === 'auto' || overflowValue === 'scroll';
          }

          /**
           * indicates if an element can be scrolled in either axis
           * @method isScrollable
           * @param {Node} el
           * @param {String} axis
           * @returns {Boolean}
           */
          function isScrollable(el) {
            var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');
            var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');
            return isScrollableY || isScrollableX;
          }

          /**
           * finds scrollable parent of an element
           * @method findScrollableParent
           * @param {Node} el
           * @returns {Node} el
           */
          function findScrollableParent(el) {
            while (el !== d.body && isScrollable(el) === false) {
              el = el.parentNode || el.host;
            }
            return el;
          }

          /**
           * self invoked function that, given a context, steps through scrolling
           * @method step
           * @param {Object} context
           * @returns {undefined}
           */
          function step(context) {
            var time = now();
            var value;
            var currentX;
            var currentY;
            var elapsed = (time - context.startTime) / SCROLL_TIME;

            // avoid elapsed times higher than one
            elapsed = elapsed > 1 ? 1 : elapsed;

            // apply easing to elapsed time
            value = ease(elapsed);
            currentX = context.startX + (context.x - context.startX) * value;
            currentY = context.startY + (context.y - context.startY) * value;
            context.method.call(context.scrollable, currentX, currentY);

            // scroll more if we have not reached our destination
            if (currentX !== context.x || currentY !== context.y) {
              w.requestAnimationFrame(step.bind(w, context));
            }
          }

          /**
           * scrolls window or element with a smooth behavior
           * @method smoothScroll
           * @param {Object|Node} el
           * @param {Number} x
           * @param {Number} y
           * @returns {undefined}
           */
          function smoothScroll(el, x, y) {
            var scrollable;
            var startX;
            var startY;
            var method;
            var startTime = now();

            // define scroll context
            if (el === d.body) {
              scrollable = w;
              startX = w.scrollX || w.pageXOffset;
              startY = w.scrollY || w.pageYOffset;
              method = original.scroll;
            } else {
              scrollable = el;
              startX = el.scrollLeft;
              startY = el.scrollTop;
              method = scrollElement;
            }

            // scroll looping over a frame
            step({
              scrollable: scrollable,
              method: method,
              startTime: startTime,
              startX: startX,
              startY: startY,
              x: x,
              y: y
            });
          }

          // ORIGINAL METHODS OVERRIDES
          // w.scroll and w.scrollTo
          w.scroll = w.scrollTo = function () {
            // avoid action when no arguments are passed
            if (arguments[0] === undefined) {
              return;
            }

            // avoid smooth behavior if not required
            if (shouldBailOut(arguments[0]) === true) {
              original.scroll.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof(arguments[0]) !== 'object' ? arguments[0] : w.scrollX || w.pageXOffset,
              // use top prop, second argument if present or fallback to scrollY
              arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : w.scrollY || w.pageYOffset);
              return;
            }

            // LET THE SMOOTHNESS BEGIN!
            smoothScroll.call(w, d.body, arguments[0].left !== undefined ? ~~arguments[0].left : w.scrollX || w.pageXOffset, arguments[0].top !== undefined ? ~~arguments[0].top : w.scrollY || w.pageYOffset);
          };

          // w.scrollBy
          w.scrollBy = function () {
            // avoid action when no arguments are passed
            if (arguments[0] === undefined) {
              return;
            }

            // avoid smooth behavior if not required
            if (shouldBailOut(arguments[0])) {
              original.scrollBy.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof(arguments[0]) !== 'object' ? arguments[0] : 0, arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : 0);
              return;
            }

            // LET THE SMOOTHNESS BEGIN!
            smoothScroll.call(w, d.body, ~~arguments[0].left + (w.scrollX || w.pageXOffset), ~~arguments[0].top + (w.scrollY || w.pageYOffset));
          };

          // Element.prototype.scroll and Element.prototype.scrollTo
          Element.prototype.scroll = Element.prototype.scrollTo = function () {
            // avoid action when no arguments are passed
            if (arguments[0] === undefined) {
              return;
            }

            // avoid smooth behavior if not required
            if (shouldBailOut(arguments[0]) === true) {
              // if one number is passed, throw error to match Firefox implementation
              if (typeof arguments[0] === 'number' && arguments[1] === undefined) {
                throw new SyntaxError('Value could not be converted');
              }
              original.elementScroll.call(this,
              // use left prop, first number argument or fallback to scrollLeft
              arguments[0].left !== undefined ? ~~arguments[0].left : _typeof(arguments[0]) !== 'object' ? ~~arguments[0] : this.scrollLeft,
              // use top prop, second argument or fallback to scrollTop
              arguments[0].top !== undefined ? ~~arguments[0].top : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop);
              return;
            }
            var left = arguments[0].left;
            var top = arguments[0].top;

            // LET THE SMOOTHNESS BEGIN!
            smoothScroll.call(this, this, typeof left === 'undefined' ? this.scrollLeft : ~~left, typeof top === 'undefined' ? this.scrollTop : ~~top);
          };

          // Element.prototype.scrollBy
          Element.prototype.scrollBy = function () {
            // avoid action when no arguments are passed
            if (arguments[0] === undefined) {
              return;
            }

            // avoid smooth behavior if not required
            if (shouldBailOut(arguments[0]) === true) {
              original.elementScroll.call(this, arguments[0].left !== undefined ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, arguments[0].top !== undefined ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop);
              return;
            }
            this.scroll({
              left: ~~arguments[0].left + this.scrollLeft,
              top: ~~arguments[0].top + this.scrollTop,
              behavior: arguments[0].behavior
            });
          };

          // Element.prototype.scrollIntoView
          Element.prototype.scrollIntoView = function () {
            // avoid smooth behavior if not required
            if (shouldBailOut(arguments[0]) === true) {
              original.scrollIntoView.call(this, arguments[0] === undefined ? true : arguments[0]);
              return;
            }

            // LET THE SMOOTHNESS BEGIN!
            var scrollableParent = findScrollableParent(this);
            var parentRects = scrollableParent.getBoundingClientRect();
            var clientRects = this.getBoundingClientRect();
            if (scrollableParent !== d.body) {
              // reveal element inside parent
              smoothScroll.call(this, scrollableParent, scrollableParent.scrollLeft + clientRects.left - parentRects.left, scrollableParent.scrollTop + clientRects.top - parentRects.top);

              // reveal parent in viewport unless is fixed
              if (w.getComputedStyle(scrollableParent).position !== 'fixed') {
                w.scrollBy({
                  left: parentRects.left,
                  top: parentRects.top,
                  behavior: 'smooth'
                });
              }
            } else {
              // reveal element in viewport
              w.scrollBy({
                left: clientRects.left,
                top: clientRects.top,
                behavior: 'smooth'
              });
            }
          };
        }
        {
          // commonjs
          module.exports = {
            polyfill: polyfill
          };
        }
      })();
    });
    var smoothscroll_1 = smoothscroll.polyfill;
    var _default$1 = /*#__PURE__*/function (_Core) {
      _inherits(_default, _Core);
      var _super = _createSuper(_default);
      function _default() {
        var _this;
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        _classCallCheck(this, _default);
        _this = _super.call(this, options);
        if (_this.resetNativeScroll) {
          if (history.scrollRestoration) {
            history.scrollRestoration = 'manual';
          }
          window.scrollTo(0, 0);
        }
        window.addEventListener('scroll', _this.checkScroll, false);
        if (window.smoothscrollPolyfill === undefined) {
          window.smoothscrollPolyfill = smoothscroll;
          window.smoothscrollPolyfill.polyfill();
        }
        return _this;
      }
      _createClass(_default, [{
        key: "init",
        value: function init() {
          this.instance.scroll.y = window.pageYOffset;
          this.addElements();
          this.detectElements();
          _get(_getPrototypeOf(_default.prototype), "init", this).call(this);
        }
      }, {
        key: "checkScroll",
        value: function checkScroll() {
          var _this2 = this;
          _get(_getPrototypeOf(_default.prototype), "checkScroll", this).call(this);
          if (this.getDirection) {
            this.addDirection();
          }
          if (this.getSpeed) {
            this.addSpeed();
            this.speedTs = Date.now();
          }
          this.instance.scroll.y = window.pageYOffset;
          if (Object.entries(this.els).length) {
            if (!this.hasScrollTicking) {
              requestAnimationFrame(function () {
                _this2.detectElements();
              });
              this.hasScrollTicking = true;
            }
          }
        }
      }, {
        key: "addDirection",
        value: function addDirection() {
          if (window.pageYOffset > this.instance.scroll.y) {
            if (this.instance.direction !== 'down') {
              this.instance.direction = 'down';
            }
          } else if (window.pageYOffset < this.instance.scroll.y) {
            if (this.instance.direction !== 'up') {
              this.instance.direction = 'up';
            }
          }
        }
      }, {
        key: "addSpeed",
        value: function addSpeed() {
          if (window.pageYOffset != this.instance.scroll.y) {
            this.instance.speed = (window.pageYOffset - this.instance.scroll.y) / Math.max(1, Date.now() - this.speedTs);
          } else {
            this.instance.speed = 0;
          }
        }
      }, {
        key: "resize",
        value: function resize() {
          if (Object.entries(this.els).length) {
            this.windowHeight = window.innerHeight;
            this.updateElements();
          }
        }
      }, {
        key: "addElements",
        value: function addElements() {
          var _this3 = this;
          this.els = {};
          var els = this.el.querySelectorAll('[data-' + this.name + ']');
          els.forEach(function (el, index) {
            var BCR = el.getBoundingClientRect();
            var cl = el.dataset[_this3.name + 'Class'] || _this3["class"];
            var id = typeof el.dataset[_this3.name + 'Id'] === 'string' ? el.dataset[_this3.name + 'Id'] : index;
            var top;
            var left;
            var offset = typeof el.dataset[_this3.name + 'Offset'] === 'string' ? el.dataset[_this3.name + 'Offset'].split(',') : _this3.offset;
            var repeat = el.dataset[_this3.name + 'Repeat'];
            var call = el.dataset[_this3.name + 'Call'];
            var target = el.dataset[_this3.name + 'Target'];
            var targetEl;
            if (target !== undefined) {
              targetEl = document.querySelector("".concat(target));
            } else {
              targetEl = el;
            }
            var targetElBCR = targetEl.getBoundingClientRect();
            top = targetElBCR.top + _this3.instance.scroll.y;
            left = targetElBCR.left + _this3.instance.scroll.x;
            var bottom = top + targetEl.offsetHeight;
            var right = left + targetEl.offsetWidth;
            if (repeat == 'false') {
              repeat = false;
            } else if (repeat != undefined) {
              repeat = true;
            } else {
              repeat = _this3.repeat;
            }
            var relativeOffset = _this3.getRelativeOffset(offset);
            top = top + relativeOffset[0];
            bottom = bottom - relativeOffset[1];
            var mappedEl = {
              el: el,
              targetEl: targetEl,
              id: id,
              "class": cl,
              top: top,
              bottom: bottom,
              left: left,
              right: right,
              offset: offset,
              progress: 0,
              repeat: repeat,
              inView: false,
              call: call
            };
            _this3.els[id] = mappedEl;
            if (el.classList.contains(cl)) {
              _this3.setInView(_this3.els[id], id);
            }
          });
        }
      }, {
        key: "updateElements",
        value: function updateElements() {
          var _this4 = this;
          Object.entries(this.els).forEach(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
              i = _ref2[0],
              el = _ref2[1];
            var top = el.targetEl.getBoundingClientRect().top + _this4.instance.scroll.y;
            var bottom = top + el.targetEl.offsetHeight;
            var relativeOffset = _this4.getRelativeOffset(el.offset);
            _this4.els[i].top = top + relativeOffset[0];
            _this4.els[i].bottom = bottom - relativeOffset[1];
          });
          this.hasScrollTicking = false;
        }
      }, {
        key: "getRelativeOffset",
        value: function getRelativeOffset(offset) {
          var relativeOffset = [0, 0];
          if (offset) {
            for (var i = 0; i < offset.length; i++) {
              if (typeof offset[i] == 'string') {
                if (offset[i].includes('%')) {
                  relativeOffset[i] = parseInt(offset[i].replace('%', '') * this.windowHeight / 100);
                } else {
                  relativeOffset[i] = parseInt(offset[i]);
                }
              } else {
                relativeOffset[i] = offset[i];
              }
            }
          }
          return relativeOffset;
        }
        /**
         * Scroll to a desired target.
         *
         * @param  Available options :
         *          target {node, string, "top", "bottom", int} - The DOM element we want to scroll to
         *          options {object} - Options object for additionnal settings.
         * @return {void}
         */
      }, {
        key: "scrollTo",
        value: function scrollTo(target) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          // Parse options
          var offset = parseInt(options.offset) || 0; // An offset to apply on top of given `target` or `sourceElem`'s target

          var callback = options.callback ? options.callback : false; // function called when scrollTo completes (note that it won't wait for lerp to stabilize)

          if (typeof target === 'string') {
            // Selector or boundaries
            if (target === 'top') {
              target = this.html;
            } else if (target === 'bottom') {
              target = this.html.offsetHeight - window.innerHeight;
            } else {
              target = document.querySelector(target); // If the query fails, abort

              if (!target) {
                return;
              }
            }
          } else if (typeof target === 'number') {
            // Absolute coordinate
            target = parseInt(target);
          } else if (target && target.tagName) ;else {
            console.warn('`target` parameter is not valid');
            return;
          } // We have a target that is not a coordinate yet, get it

          if (typeof target !== 'number') {
            offset = target.getBoundingClientRect().top + offset + this.instance.scroll.y;
          } else {
            offset = target + offset;
          }
          var isTargetReached = function isTargetReached() {
            return parseInt(window.pageYOffset) === parseInt(offset);
          };
          if (callback) {
            if (isTargetReached()) {
              callback();
              return;
            } else {
              var onScroll = function onScroll() {
                if (isTargetReached()) {
                  window.removeEventListener('scroll', onScroll);
                  callback();
                }
              };
              window.addEventListener('scroll', onScroll);
            }
          }
          window.scrollTo({
            top: offset,
            behavior: options.duration === 0 ? 'auto' : 'smooth'
          });
        }
      }, {
        key: "update",
        value: function update() {
          this.addElements();
          this.detectElements();
        }
      }, {
        key: "destroy",
        value: function destroy() {
          _get(_getPrototypeOf(_default.prototype), "destroy", this).call(this);
          window.removeEventListener('scroll', this.checkScroll, false);
        }
      }]);
      return _default;
    }(_default);

    /*
    object-assign
    (c) Sindre Sorhus
    @license MIT
    */
    /* eslint-disable no-unused-vars */
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === undefined) {
        throw new TypeError('Object.assign cannot be called with null or undefined');
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }

        // Detect buggy property enumeration order in older V8 versions.

        // https://bugs.chromium.org/p/v8/issues/detail?id=4118
        var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
        test1[5] = 'de';
        if (Object.getOwnPropertyNames(test1)[0] === '5') {
          return false;
        }

        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2['_' + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
          return test2[n];
        });
        if (order2.join('') !== '0123456789') {
          return false;
        }

        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test3 = {};
        'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
          return false;
        }
        return true;
      } catch (err) {
        // We don't expect any of the above to throw, but better to be safe.
        return false;
      }
    }
    var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
    function E() {
      // Keep this empty so it's easier to inherit from
      // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
    }
    E.prototype = {
      on: function on(name, callback, ctx) {
        var e = this.e || (this.e = {});
        (e[name] || (e[name] = [])).push({
          fn: callback,
          ctx: ctx
        });
        return this;
      },
      once: function once(name, callback, ctx) {
        var self = this;
        function listener() {
          self.off(name, listener);
          callback.apply(ctx, arguments);
        }
        listener._ = callback;
        return this.on(name, listener, ctx);
      },
      emit: function emit(name) {
        var data = [].slice.call(arguments, 1);
        var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
        var i = 0;
        var len = evtArr.length;
        for (i; i < len; i++) {
          evtArr[i].fn.apply(evtArr[i].ctx, data);
        }
        return this;
      },
      off: function off(name, callback) {
        var e = this.e || (this.e = {});
        var evts = e[name];
        var liveEvents = [];
        if (evts && callback) {
          for (var i = 0, len = evts.length; i < len; i++) {
            if (evts[i].fn !== callback && evts[i].fn._ !== callback) liveEvents.push(evts[i]);
          }
        }

        // Remove event from queue to prevent memory leak
        // Suggested by https://github.com/lazd
        // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

        liveEvents.length ? e[name] = liveEvents : delete e[name];
        return this;
      }
    };
    var tinyEmitter = E;
    var lethargy = createCommonjsModule(function (module, exports) {
      // Generated by CoffeeScript 1.9.2
      (function () {
        var root;
        root = exports !== null ? exports : this;
        root.Lethargy = function () {
          function Lethargy(stability, sensitivity, tolerance, delay) {
            this.stability = stability != null ? Math.abs(stability) : 8;
            this.sensitivity = sensitivity != null ? 1 + Math.abs(sensitivity) : 100;
            this.tolerance = tolerance != null ? 1 + Math.abs(tolerance) : 1.1;
            this.delay = delay != null ? delay : 150;
            this.lastUpDeltas = function () {
              var i, ref, results;
              results = [];
              for (i = 1, ref = this.stability * 2; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--) {
                results.push(null);
              }
              return results;
            }.call(this);
            this.lastDownDeltas = function () {
              var i, ref, results;
              results = [];
              for (i = 1, ref = this.stability * 2; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--) {
                results.push(null);
              }
              return results;
            }.call(this);
            this.deltasTimestamp = function () {
              var i, ref, results;
              results = [];
              for (i = 1, ref = this.stability * 2; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--) {
                results.push(null);
              }
              return results;
            }.call(this);
          }
          Lethargy.prototype.check = function (e) {
            var lastDelta;
            e = e.originalEvent || e;
            if (e.wheelDelta != null) {
              lastDelta = e.wheelDelta;
            } else if (e.deltaY != null) {
              lastDelta = e.deltaY * -40;
            } else if (e.detail != null || e.detail === 0) {
              lastDelta = e.detail * -40;
            }
            this.deltasTimestamp.push(Date.now());
            this.deltasTimestamp.shift();
            if (lastDelta > 0) {
              this.lastUpDeltas.push(lastDelta);
              this.lastUpDeltas.shift();
              return this.isInertia(1);
            } else {
              this.lastDownDeltas.push(lastDelta);
              this.lastDownDeltas.shift();
              return this.isInertia(-1);
            }
          };
          Lethargy.prototype.isInertia = function (direction) {
            var lastDeltas, lastDeltasNew, lastDeltasOld, newAverage, newSum, oldAverage, oldSum;
            lastDeltas = direction === -1 ? this.lastDownDeltas : this.lastUpDeltas;
            if (lastDeltas[0] === null) {
              return direction;
            }
            if (this.deltasTimestamp[this.stability * 2 - 2] + this.delay > Date.now() && lastDeltas[0] === lastDeltas[this.stability * 2 - 1]) {
              return false;
            }
            lastDeltasOld = lastDeltas.slice(0, this.stability);
            lastDeltasNew = lastDeltas.slice(this.stability, this.stability * 2);
            oldSum = lastDeltasOld.reduce(function (t, s) {
              return t + s;
            });
            newSum = lastDeltasNew.reduce(function (t, s) {
              return t + s;
            });
            oldAverage = oldSum / lastDeltasOld.length;
            newAverage = newSum / lastDeltasNew.length;
            if (Math.abs(oldAverage) < Math.abs(newAverage * this.tolerance) && this.sensitivity < Math.abs(newAverage)) {
              return direction;
            } else {
              return false;
            }
          };
          Lethargy.prototype.showLastUpDeltas = function () {
            return this.lastUpDeltas;
          };
          Lethargy.prototype.showLastDownDeltas = function () {
            return this.lastDownDeltas;
          };
          return Lethargy;
        }();
      }).call(commonjsGlobal);
    });
    var support = function getSupport() {
      return {
        hasWheelEvent: 'onwheel' in document,
        hasMouseWheelEvent: 'onmousewheel' in document,
        hasTouch: 'ontouchstart' in window || window.TouchEvent || window.DocumentTouch && document instanceof DocumentTouch,
        hasTouchWin: navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1,
        hasPointer: !!window.navigator.msPointerEnabled,
        hasKeyDown: 'onkeydown' in document,
        isFirefox: navigator.userAgent.indexOf('Firefox') > -1
      };
    }();
    var toString = Object.prototype.toString,
      hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    var bindallStandalone = function bindallStandalone(object) {
      if (!object) return console.warn('bindAll requires at least one argument.');
      var functions = Array.prototype.slice.call(arguments, 1);
      if (functions.length === 0) {
        for (var method in object) {
          if (hasOwnProperty$1.call(object, method)) {
            if (typeof object[method] == 'function' && toString.call(object[method]) == "[object Function]") {
              functions.push(method);
            }
          }
        }
      }
      for (var i = 0; i < functions.length; i++) {
        var f = functions[i];
        object[f] = bind(object[f], object);
      }
    };

    /*
        Faster bind without specific-case checking. (see https://coderwall.com/p/oi3j3w).
        bindAll is only needed for events binding so no need to make slow fixes for constructor
        or partial application.
    */
    function bind(func, context) {
      return function () {
        return func.apply(context, arguments);
      };
    }
    var Lethargy = lethargy.Lethargy;
    var EVT_ID = 'virtualscroll';
    var src = VirtualScroll;
    var keyCodes = {
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
      SPACE: 32
    };
    function VirtualScroll(options) {
      bindallStandalone(this, '_onWheel', '_onMouseWheel', '_onTouchStart', '_onTouchMove', '_onKeyDown');
      this.el = window;
      if (options && options.el) {
        this.el = options.el;
        delete options.el;
      }
      this.options = objectAssign({
        mouseMultiplier: 1,
        touchMultiplier: 2,
        firefoxMultiplier: 15,
        keyStep: 120,
        preventTouch: false,
        unpreventTouchClass: 'vs-touchmove-allowed',
        limitInertia: false,
        useKeyboard: true,
        useTouch: true
      }, options);
      if (this.options.limitInertia) this._lethargy = new Lethargy();
      this._emitter = new tinyEmitter();
      this._event = {
        y: 0,
        x: 0,
        deltaX: 0,
        deltaY: 0
      };
      this.touchStartX = null;
      this.touchStartY = null;
      this.bodyTouchAction = null;
      if (this.options.passive !== undefined) {
        this.listenerOptions = {
          passive: this.options.passive
        };
      }
    }
    VirtualScroll.prototype._notify = function (e) {
      var evt = this._event;
      evt.x += evt.deltaX;
      evt.y += evt.deltaY;
      this._emitter.emit(EVT_ID, {
        x: evt.x,
        y: evt.y,
        deltaX: evt.deltaX,
        deltaY: evt.deltaY,
        originalEvent: e
      });
    };
    VirtualScroll.prototype._onWheel = function (e) {
      var options = this.options;
      if (this._lethargy && this._lethargy.check(e) === false) return;
      var evt = this._event;

      // In Chrome and in Firefox (at least the new one)
      evt.deltaX = e.wheelDeltaX || e.deltaX * -1;
      evt.deltaY = e.wheelDeltaY || e.deltaY * -1;

      // for our purpose deltamode = 1 means user is on a wheel mouse, not touch pad
      // real meaning: https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent#Delta_modes
      if (support.isFirefox && e.deltaMode == 1) {
        evt.deltaX *= options.firefoxMultiplier;
        evt.deltaY *= options.firefoxMultiplier;
      }
      evt.deltaX *= options.mouseMultiplier;
      evt.deltaY *= options.mouseMultiplier;
      this._notify(e);
    };
    VirtualScroll.prototype._onMouseWheel = function (e) {
      if (this.options.limitInertia && this._lethargy.check(e) === false) return;
      var evt = this._event;

      // In Safari, IE and in Chrome if 'wheel' isn't defined
      evt.deltaX = e.wheelDeltaX ? e.wheelDeltaX : 0;
      evt.deltaY = e.wheelDeltaY ? e.wheelDeltaY : e.wheelDelta;
      this._notify(e);
    };
    VirtualScroll.prototype._onTouchStart = function (e) {
      var t = e.targetTouches ? e.targetTouches[0] : e;
      this.touchStartX = t.pageX;
      this.touchStartY = t.pageY;
    };
    VirtualScroll.prototype._onTouchMove = function (e) {
      var options = this.options;
      if (options.preventTouch && !e.target.classList.contains(options.unpreventTouchClass)) {
        e.preventDefault();
      }
      var evt = this._event;
      var t = e.targetTouches ? e.targetTouches[0] : e;
      evt.deltaX = (t.pageX - this.touchStartX) * options.touchMultiplier;
      evt.deltaY = (t.pageY - this.touchStartY) * options.touchMultiplier;
      this.touchStartX = t.pageX;
      this.touchStartY = t.pageY;
      this._notify(e);
    };
    VirtualScroll.prototype._onKeyDown = function (e) {
      var evt = this._event;
      evt.deltaX = evt.deltaY = 0;
      var windowHeight = window.innerHeight - 40;
      switch (e.keyCode) {
        case keyCodes.LEFT:
        case keyCodes.UP:
          evt.deltaY = this.options.keyStep;
          break;
        case keyCodes.RIGHT:
        case keyCodes.DOWN:
          evt.deltaY = -this.options.keyStep;
          break;
        case e.shiftKey:
          evt.deltaY = windowHeight;
          break;
        case keyCodes.SPACE:
          evt.deltaY = -windowHeight;
          break;
        default:
          return;
      }
      this._notify(e);
    };
    VirtualScroll.prototype._bind = function () {
      if (support.hasWheelEvent) this.el.addEventListener('wheel', this._onWheel, this.listenerOptions);
      if (support.hasMouseWheelEvent) this.el.addEventListener('mousewheel', this._onMouseWheel, this.listenerOptions);
      if (support.hasTouch && this.options.useTouch) {
        this.el.addEventListener('touchstart', this._onTouchStart, this.listenerOptions);
        this.el.addEventListener('touchmove', this._onTouchMove, this.listenerOptions);
      }
      if (support.hasPointer && support.hasTouchWin) {
        this.bodyTouchAction = document.body.style.msTouchAction;
        document.body.style.msTouchAction = 'none';
        this.el.addEventListener('MSPointerDown', this._onTouchStart, true);
        this.el.addEventListener('MSPointerMove', this._onTouchMove, true);
      }
      if (support.hasKeyDown && this.options.useKeyboard) document.addEventListener('keydown', this._onKeyDown);
    };
    VirtualScroll.prototype._unbind = function () {
      if (support.hasWheelEvent) this.el.removeEventListener('wheel', this._onWheel);
      if (support.hasMouseWheelEvent) this.el.removeEventListener('mousewheel', this._onMouseWheel);
      if (support.hasTouch) {
        this.el.removeEventListener('touchstart', this._onTouchStart);
        this.el.removeEventListener('touchmove', this._onTouchMove);
      }
      if (support.hasPointer && support.hasTouchWin) {
        document.body.style.msTouchAction = this.bodyTouchAction;
        this.el.removeEventListener('MSPointerDown', this._onTouchStart, true);
        this.el.removeEventListener('MSPointerMove', this._onTouchMove, true);
      }
      if (support.hasKeyDown && this.options.useKeyboard) document.removeEventListener('keydown', this._onKeyDown);
    };
    VirtualScroll.prototype.on = function (cb, ctx) {
      this._emitter.on(EVT_ID, cb, ctx);
      var events = this._emitter.e;
      if (events && events[EVT_ID] && events[EVT_ID].length === 1) this._bind();
    };
    VirtualScroll.prototype.off = function (cb, ctx) {
      this._emitter.off(EVT_ID, cb, ctx);
      var events = this._emitter.e;
      if (!events[EVT_ID] || events[EVT_ID].length <= 0) this._unbind();
    };
    VirtualScroll.prototype.reset = function () {
      var evt = this._event;
      evt.x = 0;
      evt.y = 0;
    };
    VirtualScroll.prototype.destroy = function () {
      this._emitter.off();
      this._unbind();
    };
    function lerp(start, end, amt) {
      return (1 - amt) * start + amt * end;
    }
    function getTranslate(el) {
      var translate = {};
      if (!window.getComputedStyle) return;
      var style = getComputedStyle(el);
      var transform = style.transform || style.webkitTransform || style.mozTransform;
      var mat = transform.match(/^matrix3d\((.+)\)$/);
      if (mat) {
        translate.x = mat ? parseFloat(mat[1].split(', ')[12]) : 0;
        translate.y = mat ? parseFloat(mat[1].split(', ')[13]) : 0;
      } else {
        mat = transform.match(/^matrix\((.+)\)$/);
        translate.x = mat ? parseFloat(mat[1].split(', ')[4]) : 0;
        translate.y = mat ? parseFloat(mat[1].split(', ')[5]) : 0;
      }
      return translate;
    }

    /**
     * Returns an array containing all the parent nodes of the given node
     * @param  {object} node
     * @return {array} parent nodes
     */
    function getParents(elem) {
      // Set up a parent array
      var parents = []; // Push each parent element to the array

      for (; elem && elem !== document; elem = elem.parentNode) {
        parents.push(elem);
      } // Return our parent array

      return parents;
    } // https://gomakethings.com/how-to-get-the-closest-parent-element-with-a-matching-selector-using-vanilla-javascript/

    /**
     * https://github.com/gre/bezier-easing
     * BezierEasing - use bezier curve for transition easing function
     * by Gaëtan Renaudeau 2014 - 2015 – MIT License
     */

    // These values are established by empiricism with tests (tradeoff: performance VS precision)
    var NEWTON_ITERATIONS = 4;
    var NEWTON_MIN_SLOPE = 0.001;
    var SUBDIVISION_PRECISION = 0.0000001;
    var SUBDIVISION_MAX_ITERATIONS = 10;
    var kSplineTableSize = 11;
    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
    var float32ArraySupported = typeof Float32Array === 'function';
    function A(aA1, aA2) {
      return 1.0 - 3.0 * aA2 + 3.0 * aA1;
    }
    function B(aA1, aA2) {
      return 3.0 * aA2 - 6.0 * aA1;
    }
    function C(aA1) {
      return 3.0 * aA1;
    }

    // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
    function calcBezier(aT, aA1, aA2) {
      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
    }

    // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
    function getSlope(aT, aA1, aA2) {
      return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
    }
    function binarySubdivide(aX, aA, aB, mX1, mX2) {
      var currentX,
        currentT,
        i = 0;
      do {
        currentT = aA + (aB - aA) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - aX;
        if (currentX > 0.0) {
          aB = currentT;
        } else {
          aA = currentT;
        }
      } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
      return currentT;
    }
    function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
      for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
        var currentSlope = getSlope(aGuessT, mX1, mX2);
        if (currentSlope === 0.0) {
          return aGuessT;
        }
        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
        aGuessT -= currentX / currentSlope;
      }
      return aGuessT;
    }
    function LinearEasing(x) {
      return x;
    }
    var src$1 = function bezier(mX1, mY1, mX2, mY2) {
      if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
        throw new Error('bezier x values must be in [0, 1] range');
      }
      if (mX1 === mY1 && mX2 === mY2) {
        return LinearEasing;
      }

      // Precompute samples table
      var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
      function getTForX(aX) {
        var intervalStart = 0.0;
        var currentSample = 1;
        var lastSample = kSplineTableSize - 1;
        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
          intervalStart += kSampleStepSize;
        }
        --currentSample;

        // Interpolate to provide an initial guess for t
        var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        var guessForT = intervalStart + dist * kSampleStepSize;
        var initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
          return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
        } else if (initialSlope === 0.0) {
          return guessForT;
        } else {
          return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
      }
      return function BezierEasing(x) {
        // Because JavaScript number are imprecise, we should guarantee the extremes are right.
        if (x === 0) {
          return 0;
        }
        if (x === 1) {
          return 1;
        }
        return calcBezier(getTForX(x), mY1, mY2);
      };
    };
    var keyCodes$1 = {
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
      SPACE: 32,
      TAB: 9,
      PAGEUP: 33,
      PAGEDOWN: 34,
      HOME: 36,
      END: 35
    };
    var _default$2 = /*#__PURE__*/function (_Core) {
      _inherits(_default, _Core);
      var _super = _createSuper(_default);
      function _default() {
        var _this;
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        _classCallCheck(this, _default);
        if (history.scrollRestoration) {
          history.scrollRestoration = 'manual';
        }
        window.scrollTo(0, 0);
        _this = _super.call(this, options);
        if (_this.inertia) _this.lerp = _this.inertia * 0.1;
        _this.isScrolling = false;
        _this.isDraggingScrollbar = false;
        _this.isTicking = false;
        _this.hasScrollTicking = false;
        _this.parallaxElements = {};
        _this.stop = false;
        _this.scrollbarContainer = options.scrollbarContainer;
        _this.checkKey = _this.checkKey.bind(_assertThisInitialized(_this));
        window.addEventListener('keydown', _this.checkKey, false);
        return _this;
      }
      _createClass(_default, [{
        key: "init",
        value: function init() {
          var _this2 = this;
          this.html.classList.add(this.smoothClass);
          this.html.setAttribute("data-".concat(this.name, "-direction"), this.direction);
          this.instance = _objectSpread2({
            delta: {
              x: this.initPosition.x,
              y: this.initPosition.y
            },
            scroll: {
              x: this.initPosition.x,
              y: this.initPosition.y
            }
          }, this.instance);
          this.vs = new src({
            el: this.scrollFromAnywhere ? document : this.el,
            mouseMultiplier: navigator.platform.indexOf('Win') > -1 ? 1 : 0.4,
            firefoxMultiplier: this.firefoxMultiplier,
            touchMultiplier: this.touchMultiplier,
            useKeyboard: false,
            passive: true
          });
          this.vs.on(function (e) {
            if (_this2.stop) {
              return;
            }
            if (!_this2.isDraggingScrollbar) {
              requestAnimationFrame(function () {
                _this2.updateDelta(e);
                if (!_this2.isScrolling) _this2.startScrolling();
              });
            }
          });
          this.setScrollLimit();
          this.initScrollBar();
          this.addSections();
          this.addElements();
          this.checkScroll(true);
          this.transformElements(true, true);
          _get(_getPrototypeOf(_default.prototype), "init", this).call(this);
        }
      }, {
        key: "setScrollLimit",
        value: function setScrollLimit() {
          this.instance.limit.y = this.el.offsetHeight - this.windowHeight;
          if (this.direction === 'horizontal') {
            var totalWidth = 0;
            var nodes = this.el.children;
            for (var i = 0; i < nodes.length; i++) {
              totalWidth += nodes[i].offsetWidth;
            }
            this.instance.limit.x = totalWidth - this.windowWidth;
          }
        }
      }, {
        key: "startScrolling",
        value: function startScrolling() {
          this.startScrollTs = Date.now(); // Record timestamp

          this.isScrolling = true;
          this.checkScroll();
          this.html.classList.add(this.scrollingClass);
        }
      }, {
        key: "stopScrolling",
        value: function stopScrolling() {
          cancelAnimationFrame(this.checkScrollRaf); // Prevent checkScroll to continue looping
          //Pevent scrollbar glitch/locking

          this.startScrollTs = undefined;
          if (this.scrollToRaf) {
            cancelAnimationFrame(this.scrollToRaf);
            this.scrollToRaf = null;
          }
          this.isScrolling = false;
          this.instance.scroll.y = Math.round(this.instance.scroll.y);
          this.html.classList.remove(this.scrollingClass);
        }
      }, {
        key: "checkKey",
        value: function checkKey(e) {
          var _this3 = this;
          if (this.stop) {
            // If we are stopped, we don't want any scroll to occur because of a keypress
            // Prevent tab to scroll to activeElement
            if (e.keyCode == keyCodes$1.TAB) {
              requestAnimationFrame(function () {
                // Make sure native scroll is always at top of page
                _this3.html.scrollTop = 0;
                document.body.scrollTop = 0;
                _this3.html.scrollLeft = 0;
                document.body.scrollLeft = 0;
              });
            }
            return;
          }
          switch (e.keyCode) {
            case keyCodes$1.TAB:
              // Do not remove the RAF
              // It allows to override the browser's native scrollTo, which is essential
              requestAnimationFrame(function () {
                // Make sure native scroll is always at top of page
                _this3.html.scrollTop = 0;
                document.body.scrollTop = 0;
                _this3.html.scrollLeft = 0;
                document.body.scrollLeft = 0; // Request scrollTo on the focusedElement, putting it at the center of the screen

                _this3.scrollTo(document.activeElement, {
                  offset: -window.innerHeight / 2
                });
              });
              break;
            case keyCodes$1.UP:
              if (this.isActiveElementScrollSensitive()) {
                this.instance.delta[this.directionAxis] -= 240;
              }
              break;
            case keyCodes$1.DOWN:
              if (this.isActiveElementScrollSensitive()) {
                this.instance.delta[this.directionAxis] += 240;
              }
              break;
            case keyCodes$1.PAGEUP:
              this.instance.delta[this.directionAxis] -= window.innerHeight;
              break;
            case keyCodes$1.PAGEDOWN:
              this.instance.delta[this.directionAxis] += window.innerHeight;
              break;
            case keyCodes$1.HOME:
              this.instance.delta[this.directionAxis] -= this.instance.limit[this.directionAxis];
              break;
            case keyCodes$1.END:
              this.instance.delta[this.directionAxis] += this.instance.limit[this.directionAxis];
              break;
            case keyCodes$1.SPACE:
              if (this.isActiveElementScrollSensitive()) {
                if (e.shiftKey) {
                  this.instance.delta[this.directionAxis] -= window.innerHeight;
                } else {
                  this.instance.delta[this.directionAxis] += window.innerHeight;
                }
              }
              break;
            default:
              return;
          }
          if (this.instance.delta[this.directionAxis] < 0) this.instance.delta[this.directionAxis] = 0;
          if (this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis]) this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis];
          this.stopScrolling(); // Stop any movement, allows to kill any other `scrollTo` still happening

          this.isScrolling = true;
          this.checkScroll();
          this.html.classList.add(this.scrollingClass);
        }
      }, {
        key: "isActiveElementScrollSensitive",
        value: function isActiveElementScrollSensitive() {
          return !(document.activeElement instanceof HTMLInputElement) && !(document.activeElement instanceof HTMLTextAreaElement) && !(document.activeElement instanceof HTMLButtonElement) && !(document.activeElement instanceof HTMLSelectElement);
        }
      }, {
        key: "checkScroll",
        value: function checkScroll() {
          var _this4 = this;
          var forced = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          if (forced || this.isScrolling || this.isDraggingScrollbar) {
            if (!this.hasScrollTicking) {
              this.checkScrollRaf = requestAnimationFrame(function () {
                return _this4.checkScroll();
              });
              this.hasScrollTicking = true;
            }
            this.updateScroll();
            var distance = Math.abs(this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]);
            var timeSinceStart = Date.now() - this.startScrollTs; // Get the time since the scroll was started: the scroll can be stopped again only past 100ms

            if (!this.animatingScroll && timeSinceStart > 100 && (distance < 0.5 && this.instance.delta[this.directionAxis] != 0 || distance < 0.5 && this.instance.delta[this.directionAxis] == 0)) {
              this.stopScrolling();
            }
            Object.entries(this.sections).forEach(function (_ref) {
              var _ref2 = _slicedToArray(_ref, 2),
                i = _ref2[0],
                section = _ref2[1];
              if (section.persistent || _this4.instance.scroll[_this4.directionAxis] > section.offset[_this4.directionAxis] && _this4.instance.scroll[_this4.directionAxis] < section.limit[_this4.directionAxis]) {
                if (_this4.direction === 'horizontal') {
                  _this4.transform(section.el, -_this4.instance.scroll[_this4.directionAxis], 0);
                } else {
                  _this4.transform(section.el, 0, -_this4.instance.scroll[_this4.directionAxis]);
                }
                if (!section.inView) {
                  section.inView = true;
                  section.el.style.opacity = 1;
                  section.el.style.pointerEvents = 'all';
                  section.el.setAttribute("data-".concat(_this4.name, "-section-inview"), '');
                }
              } else {
                if (section.inView || forced) {
                  section.inView = false;
                  section.el.style.opacity = 0;
                  section.el.style.pointerEvents = 'none';
                  section.el.removeAttribute("data-".concat(_this4.name, "-section-inview"));
                }
                _this4.transform(section.el, 0, 0);
              }
            });
            if (this.getDirection) {
              this.addDirection();
            }
            if (this.getSpeed) {
              this.addSpeed();
              this.speedTs = Date.now();
            }
            this.detectElements();
            this.transformElements();
            if (this.hasScrollbar) {
              var scrollBarTranslation = this.instance.scroll[this.directionAxis] / this.instance.limit[this.directionAxis] * this.scrollBarLimit[this.directionAxis];
              if (this.direction === 'horizontal') {
                this.transform(this.scrollbarThumb, scrollBarTranslation, 0);
              } else {
                this.transform(this.scrollbarThumb, 0, scrollBarTranslation);
              }
            }
            _get(_getPrototypeOf(_default.prototype), "checkScroll", this).call(this);
            this.hasScrollTicking = false;
          }
        }
      }, {
        key: "resize",
        value: function resize() {
          this.windowHeight = window.innerHeight;
          this.windowWidth = window.innerWidth;
          this.checkContext();
          this.windowMiddle = {
            x: this.windowWidth / 2,
            y: this.windowHeight / 2
          };
          this.update();
        }
      }, {
        key: "updateDelta",
        value: function updateDelta(e) {
          var delta;
          var gestureDirection = this[this.context] && this[this.context].gestureDirection ? this[this.context].gestureDirection : this.gestureDirection;
          if (gestureDirection === 'both') {
            delta = e.deltaX + e.deltaY;
          } else if (gestureDirection === 'vertical') {
            delta = e.deltaY;
          } else if (gestureDirection === 'horizontal') {
            delta = e.deltaX;
          } else {
            delta = e.deltaY;
          }
          this.instance.delta[this.directionAxis] -= delta * this.multiplier;
          if (this.instance.delta[this.directionAxis] < 0) this.instance.delta[this.directionAxis] = 0;
          if (this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis]) this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis];
        }
      }, {
        key: "updateScroll",
        value: function updateScroll(e) {
          if (this.isScrolling || this.isDraggingScrollbar) {
            this.instance.scroll[this.directionAxis] = lerp(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis], this.lerp);
          } else {
            if (this.instance.scroll[this.directionAxis] > this.instance.limit[this.directionAxis]) {
              this.setScroll(this.instance.scroll[this.directionAxis], this.instance.limit[this.directionAxis]);
            } else if (this.instance.scroll.y < 0) {
              this.setScroll(this.instance.scroll[this.directionAxis], 0);
            } else {
              this.setScroll(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis]);
            }
          }
        }
      }, {
        key: "addDirection",
        value: function addDirection() {
          if (this.instance.delta.y > this.instance.scroll.y) {
            if (this.instance.direction !== 'down') {
              this.instance.direction = 'down';
            }
          } else if (this.instance.delta.y < this.instance.scroll.y) {
            if (this.instance.direction !== 'up') {
              this.instance.direction = 'up';
            }
          }
          if (this.instance.delta.x > this.instance.scroll.x) {
            if (this.instance.direction !== 'right') {
              this.instance.direction = 'right';
            }
          } else if (this.instance.delta.x < this.instance.scroll.x) {
            if (this.instance.direction !== 'left') {
              this.instance.direction = 'left';
            }
          }
        }
      }, {
        key: "addSpeed",
        value: function addSpeed() {
          if (this.instance.delta[this.directionAxis] != this.instance.scroll[this.directionAxis]) {
            this.instance.speed = (this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]) / Math.max(1, Date.now() - this.speedTs);
          } else {
            this.instance.speed = 0;
          }
        }
      }, {
        key: "initScrollBar",
        value: function initScrollBar() {
          this.scrollbar = document.createElement('span');
          this.scrollbarThumb = document.createElement('span');
          this.scrollbar.classList.add("".concat(this.scrollbarClass));
          this.scrollbarThumb.classList.add("".concat(this.scrollbarClass, "_thumb"));
          this.scrollbar.append(this.scrollbarThumb);
          if (this.scrollbarContainer) {
            this.scrollbarContainer.append(this.scrollbar);
          } else {
            document.body.append(this.scrollbar);
          } // Scrollbar Events

          this.getScrollBar = this.getScrollBar.bind(this);
          this.releaseScrollBar = this.releaseScrollBar.bind(this);
          this.moveScrollBar = this.moveScrollBar.bind(this);
          this.scrollbarThumb.addEventListener('mousedown', this.getScrollBar);
          window.addEventListener('mouseup', this.releaseScrollBar);
          window.addEventListener('mousemove', this.moveScrollBar); // Set scrollbar values

          this.hasScrollbar = false;
          if (this.direction == 'horizontal') {
            if (this.instance.limit.x + this.windowWidth <= this.windowWidth) {
              return;
            }
          } else {
            if (this.instance.limit.y + this.windowHeight <= this.windowHeight) {
              return;
            }
          }
          this.hasScrollbar = true;
          this.scrollbarBCR = this.scrollbar.getBoundingClientRect();
          this.scrollbarHeight = this.scrollbarBCR.height;
          this.scrollbarWidth = this.scrollbarBCR.width;
          if (this.direction === 'horizontal') {
            this.scrollbarThumb.style.width = "".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), "px");
          } else {
            this.scrollbarThumb.style.height = "".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), "px");
          }
          this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect();
          this.scrollBarLimit = {
            x: this.scrollbarWidth - this.scrollbarThumbBCR.width,
            y: this.scrollbarHeight - this.scrollbarThumbBCR.height
          };
        }
      }, {
        key: "reinitScrollBar",
        value: function reinitScrollBar() {
          this.hasScrollbar = false;
          if (this.direction == 'horizontal') {
            if (this.instance.limit.x + this.windowWidth <= this.windowWidth) {
              return;
            }
          } else {
            if (this.instance.limit.y + this.windowHeight <= this.windowHeight) {
              return;
            }
          }
          this.hasScrollbar = true;
          this.scrollbarBCR = this.scrollbar.getBoundingClientRect();
          this.scrollbarHeight = this.scrollbarBCR.height;
          this.scrollbarWidth = this.scrollbarBCR.width;
          if (this.direction === 'horizontal') {
            this.scrollbarThumb.style.width = "".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), "px");
          } else {
            this.scrollbarThumb.style.height = "".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), "px");
          }
          this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect();
          this.scrollBarLimit = {
            x: this.scrollbarWidth - this.scrollbarThumbBCR.width,
            y: this.scrollbarHeight - this.scrollbarThumbBCR.height
          };
        }
      }, {
        key: "destroyScrollBar",
        value: function destroyScrollBar() {
          this.scrollbarThumb.removeEventListener('mousedown', this.getScrollBar);
          window.removeEventListener('mouseup', this.releaseScrollBar);
          window.removeEventListener('mousemove', this.moveScrollBar);
          this.scrollbar.remove();
        }
      }, {
        key: "getScrollBar",
        value: function getScrollBar(e) {
          this.isDraggingScrollbar = true;
          this.checkScroll();
          this.html.classList.remove(this.scrollingClass);
          this.html.classList.add(this.draggingClass);
        }
      }, {
        key: "releaseScrollBar",
        value: function releaseScrollBar(e) {
          this.isDraggingScrollbar = false;
          if (this.isScrolling) {
            this.html.classList.add(this.scrollingClass);
          }
          this.html.classList.remove(this.draggingClass);
        }
      }, {
        key: "moveScrollBar",
        value: function moveScrollBar(e) {
          var _this5 = this;
          if (this.isDraggingScrollbar) {
            requestAnimationFrame(function () {
              var x = (e.clientX - _this5.scrollbarBCR.left) * 100 / _this5.scrollbarWidth * _this5.instance.limit.x / 100;
              var y = (e.clientY - _this5.scrollbarBCR.top) * 100 / _this5.scrollbarHeight * _this5.instance.limit.y / 100;
              if (y > 0 && y < _this5.instance.limit.y) {
                _this5.instance.delta.y = y;
              }
              if (x > 0 && x < _this5.instance.limit.x) {
                _this5.instance.delta.x = x;
              }
            });
          }
        }
      }, {
        key: "addElements",
        value: function addElements() {
          var _this6 = this;
          this.els = {};
          this.parallaxElements = {}; // this.sections.forEach((section, y) => {

          var els = this.el.querySelectorAll("[data-".concat(this.name, "]"));
          els.forEach(function (el, index) {
            // Try and find the target's parent section
            var targetParents = getParents(el);
            var section = Object.entries(_this6.sections).map(function (_ref3) {
              var _ref4 = _slicedToArray(_ref3, 2),
                key = _ref4[0],
                section = _ref4[1];
              return section;
            }).find(function (section) {
              return targetParents.includes(section.el);
            });
            var cl = el.dataset[_this6.name + 'Class'] || _this6["class"];
            var id = typeof el.dataset[_this6.name + 'Id'] === 'string' ? el.dataset[_this6.name + 'Id'] : 'el' + index;
            var top;
            var left;
            var repeat = el.dataset[_this6.name + 'Repeat'];
            var call = el.dataset[_this6.name + 'Call'];
            var position = el.dataset[_this6.name + 'Position'];
            var delay = el.dataset[_this6.name + 'Delay'];
            var direction = el.dataset[_this6.name + 'Direction'];
            var sticky = typeof el.dataset[_this6.name + 'Sticky'] === 'string';
            var speed = el.dataset[_this6.name + 'Speed'] ? parseFloat(el.dataset[_this6.name + 'Speed']) / 10 : false;
            var offset = typeof el.dataset[_this6.name + 'Offset'] === 'string' ? el.dataset[_this6.name + 'Offset'].split(',') : _this6.offset;
            var target = el.dataset[_this6.name + 'Target'];
            var targetEl;
            if (target !== undefined) {
              targetEl = document.querySelector("".concat(target));
            } else {
              targetEl = el;
            }
            var targetElBCR = targetEl.getBoundingClientRect();
            if (section === null) {
              top = targetElBCR.top + _this6.instance.scroll.y - getTranslate(targetEl).y;
              left = targetElBCR.left + _this6.instance.scroll.x - getTranslate(targetEl).x;
            } else {
              if (!section.inView) {
                top = targetElBCR.top - getTranslate(section.el).y - getTranslate(targetEl).y;
                left = targetElBCR.left - getTranslate(section.el).x - getTranslate(targetEl).x;
              } else {
                top = targetElBCR.top + _this6.instance.scroll.y - getTranslate(targetEl).y;
                left = targetElBCR.left + _this6.instance.scroll.x - getTranslate(targetEl).x;
              }
            }
            var bottom = top + targetEl.offsetHeight;
            var right = left + targetEl.offsetWidth;
            var middle = {
              x: (right - left) / 2 + left,
              y: (bottom - top) / 2 + top
            };
            if (sticky) {
              var elBCR = el.getBoundingClientRect();
              var elTop = elBCR.top;
              var elLeft = elBCR.left;
              var elDistance = {
                x: elLeft - left,
                y: elTop - top
              };
              top += window.innerHeight;
              left += window.innerWidth;
              bottom = elTop + targetEl.offsetHeight - el.offsetHeight - elDistance[_this6.directionAxis];
              right = elLeft + targetEl.offsetWidth - el.offsetWidth - elDistance[_this6.directionAxis];
              middle = {
                x: (right - left) / 2 + left,
                y: (bottom - top) / 2 + top
              };
            }
            if (repeat == 'false') {
              repeat = false;
            } else if (repeat != undefined) {
              repeat = true;
            } else {
              repeat = _this6.repeat;
            }
            var relativeOffset = [0, 0];
            if (offset) {
              if (_this6.direction === 'horizontal') {
                for (var i = 0; i < offset.length; i++) {
                  if (typeof offset[i] == 'string') {
                    if (offset[i].includes('%')) {
                      relativeOffset[i] = parseInt(offset[i].replace('%', '') * _this6.windowWidth / 100);
                    } else {
                      relativeOffset[i] = parseInt(offset[i]);
                    }
                  } else {
                    relativeOffset[i] = offset[i];
                  }
                }
                left = left + relativeOffset[0];
                right = right - relativeOffset[1];
              } else {
                for (var i = 0; i < offset.length; i++) {
                  if (typeof offset[i] == 'string') {
                    if (offset[i].includes('%')) {
                      relativeOffset[i] = parseInt(offset[i].replace('%', '') * _this6.windowHeight / 100);
                    } else {
                      relativeOffset[i] = parseInt(offset[i]);
                    }
                  } else {
                    relativeOffset[i] = offset[i];
                  }
                }
                top = top + relativeOffset[0];
                bottom = bottom - relativeOffset[1];
              }
            }
            var mappedEl = {
              el: el,
              id: id,
              "class": cl,
              section: section,
              top: top,
              middle: middle,
              bottom: bottom,
              left: left,
              right: right,
              offset: offset,
              progress: 0,
              repeat: repeat,
              inView: false,
              call: call,
              speed: speed,
              delay: delay,
              position: position,
              target: targetEl,
              direction: direction,
              sticky: sticky
            };
            _this6.els[id] = mappedEl;
            if (el.classList.contains(cl)) {
              _this6.setInView(_this6.els[id], id);
            }
            if (speed !== false || sticky) {
              _this6.parallaxElements[id] = mappedEl;
            }
          }); // });
        }
      }, {
        key: "addSections",
        value: function addSections() {
          var _this7 = this;
          this.sections = {};
          var sections = this.el.querySelectorAll("[data-".concat(this.name, "-section]"));
          if (sections.length === 0) {
            sections = [this.el];
          }
          sections.forEach(function (section, index) {
            var id = typeof section.dataset[_this7.name + 'Id'] === 'string' ? section.dataset[_this7.name + 'Id'] : 'section' + index;
            var sectionBCR = section.getBoundingClientRect();
            var offset = {
              x: sectionBCR.left - window.innerWidth * 1.5 - getTranslate(section).x,
              y: sectionBCR.top - window.innerHeight * 1.5 - getTranslate(section).y
            };
            var limit = {
              x: offset.x + sectionBCR.width + window.innerWidth * 2,
              y: offset.y + sectionBCR.height + window.innerHeight * 2
            };
            var persistent = typeof section.dataset[_this7.name + 'Persistent'] === 'string';
            section.setAttribute('data-scroll-section-id', id);
            var mappedSection = {
              el: section,
              offset: offset,
              limit: limit,
              inView: false,
              persistent: persistent,
              id: id
            };
            _this7.sections[id] = mappedSection;
          });
        }
      }, {
        key: "transform",
        value: function transform(element, x, y, delay) {
          var transform;
          if (!delay) {
            transform = "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,".concat(x, ",").concat(y, ",0,1)");
          } else {
            var start = getTranslate(element);
            var lerpX = lerp(start.x, x, delay);
            var lerpY = lerp(start.y, y, delay);
            transform = "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,".concat(lerpX, ",").concat(lerpY, ",0,1)");
          }
          element.style.webkitTransform = transform;
          element.style.msTransform = transform;
          element.style.transform = transform;
        }
      }, {
        key: "transformElements",
        value: function transformElements(isForced) {
          var _this8 = this;
          var setAllElements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var scrollRight = this.instance.scroll.x + this.windowWidth;
          var scrollBottom = this.instance.scroll.y + this.windowHeight;
          var scrollMiddle = {
            x: this.instance.scroll.x + this.windowMiddle.x,
            y: this.instance.scroll.y + this.windowMiddle.y
          };
          Object.entries(this.parallaxElements).forEach(function (_ref5) {
            var _ref6 = _slicedToArray(_ref5, 2),
              i = _ref6[0],
              current = _ref6[1];
            var transformDistance = false;
            if (isForced) {
              transformDistance = 0;
            }
            if (current.inView || setAllElements) {
              switch (current.position) {
                case 'top':
                  transformDistance = _this8.instance.scroll[_this8.directionAxis] * -current.speed;
                  break;
                case 'elementTop':
                  transformDistance = (scrollBottom - current.top) * -current.speed;
                  break;
                case 'bottom':
                  transformDistance = (_this8.instance.limit[_this8.directionAxis] - scrollBottom + _this8.windowHeight) * current.speed;
                  break;
                case 'left':
                  transformDistance = _this8.instance.scroll[_this8.directionAxis] * -current.speed;
                  break;
                case 'elementLeft':
                  transformDistance = (scrollRight - current.left) * -current.speed;
                  break;
                case 'right':
                  transformDistance = (_this8.instance.limit[_this8.directionAxis] - scrollRight + _this8.windowHeight) * current.speed;
                  break;
                default:
                  transformDistance = (scrollMiddle[_this8.directionAxis] - current.middle[_this8.directionAxis]) * -current.speed;
                  break;
              }
            }
            if (current.sticky) {
              if (current.inView) {
                if (_this8.direction === 'horizontal') {
                  transformDistance = _this8.instance.scroll.x - current.left + window.innerWidth;
                } else {
                  transformDistance = _this8.instance.scroll.y - current.top + window.innerHeight;
                }
              } else {
                if (_this8.direction === 'horizontal') {
                  if (_this8.instance.scroll.x < current.left - window.innerWidth && _this8.instance.scroll.x < current.left - window.innerWidth / 2) {
                    transformDistance = 0;
                  } else if (_this8.instance.scroll.x > current.right && _this8.instance.scroll.x > current.right + 100) {
                    transformDistance = current.right - current.left + window.innerWidth;
                  } else {
                    transformDistance = false;
                  }
                } else {
                  if (_this8.instance.scroll.y < current.top - window.innerHeight && _this8.instance.scroll.y < current.top - window.innerHeight / 2) {
                    transformDistance = 0;
                  } else if (_this8.instance.scroll.y > current.bottom && _this8.instance.scroll.y > current.bottom + 100) {
                    transformDistance = current.bottom - current.top + window.innerHeight;
                  } else {
                    transformDistance = false;
                  }
                }
              }
            }
            if (transformDistance !== false) {
              if (current.direction === 'horizontal' || _this8.direction === 'horizontal' && current.direction !== 'vertical') {
                _this8.transform(current.el, transformDistance, 0, isForced ? false : current.delay);
              } else {
                _this8.transform(current.el, 0, transformDistance, isForced ? false : current.delay);
              }
            }
          });
        }
        /**
         * Scroll to a desired target.
         *
         * @param  Available options :
         *          target {node, string, "top", "bottom", int} - The DOM element we want to scroll to
         *          options {object} - Options object for additionnal settings.
         * @return {void}
         */
      }, {
        key: "scrollTo",
        value: function scrollTo(target) {
          var _this9 = this;
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          // Parse options
          var offset = parseInt(options.offset) || 0; // An offset to apply on top of given `target` or `sourceElem`'s target

          var duration = !isNaN(parseInt(options.duration)) ? parseInt(options.duration) : 1000; // Duration of the scroll animation in milliseconds

          var easing = options.easing || [0.25, 0.0, 0.35, 1.0]; // An array of 4 floats between 0 and 1 defining the bezier curve for the animation's easing. See http://greweb.me/bezier-easing-editor/example/

          var disableLerp = options.disableLerp ? true : false; // Lerp effect won't be applied if set to true

          var callback = options.callback ? options.callback : false; // function called when scrollTo completes (note that it won't wait for lerp to stabilize)

          easing = src$1.apply(void 0, _toConsumableArray(easing));
          if (typeof target === 'string') {
            // Selector or boundaries
            if (target === 'top') {
              target = 0;
            } else if (target === 'bottom') {
              target = this.instance.limit.y;
            } else if (target === 'left') {
              target = 0;
            } else if (target === 'right') {
              target = this.instance.limit.x;
            } else {
              target = document.getElementById(target); // If the query fails, abort

              if (!target) {
                return;
              }
            }
          } else if (typeof target === 'number') {
            // Absolute coordinate
            target = parseInt(target);
          } else if (target && target.tagName) ;else {
            console.warn('`target` parameter is not valid');
            return;
          } // We have a target that is not a coordinate yet, get it

          if (typeof target !== 'number') {
            // Verify the given target belongs to this scroll scope
            var targetInScope = getParents(target).includes(this.el);
            if (!targetInScope) {
              // If the target isn't inside our main element, abort any action
              return;
            } // Get target offset from top

            var targetBCR = target.getBoundingClientRect();
            var offsetTop = targetBCR.top;
            var offsetLeft = targetBCR.left; // Try and find the target's parent section

            var targetParents = getParents(target);
            var parentSection = targetParents.find(function (candidate) {
              return Object.entries(_this9.sections) // Get sections associative array as a regular array
              .map(function (_ref7) {
                var _ref8 = _slicedToArray(_ref7, 2),
                  key = _ref8[0],
                  section = _ref8[1];
                return section;
              }) // map to section only (we dont need the key here)
              .find(function (section) {
                return section.el == candidate;
              }); // finally find the section that matches the candidate
            });

            var parentSectionOffset = 0;
            if (parentSection) {
              parentSectionOffset = getTranslate(parentSection)[this.directionAxis]; // We got a parent section, store it's current offset to remove it later
            } else {
              // if no parent section is found we need to use instance scroll directly
              parentSectionOffset = -this.instance.scroll[this.directionAxis];
            } // Final value of scroll destination : offsetTop + (optional offset given in options) - (parent's section translate)

            if (this.direction === 'horizontal') {
              offset = offsetLeft + offset - parentSectionOffset;
            } else {
              offset = offsetTop + offset - parentSectionOffset;
            }
          } else {
            offset = target + offset;
          } // Actual scrollto
          // ==========================================================================
          // Setup

          var scrollStart = parseFloat(this.instance.delta[this.directionAxis]);
          var scrollTarget = Math.max(0, Math.min(offset, this.instance.limit[this.directionAxis])); // Make sure our target is in the scroll boundaries

          var scrollDiff = scrollTarget - scrollStart;
          var render = function render(p) {
            if (disableLerp) {
              if (_this9.direction === 'horizontal') {
                _this9.setScroll(scrollStart + scrollDiff * p, _this9.instance.delta.y);
              } else {
                _this9.setScroll(_this9.instance.delta.x, scrollStart + scrollDiff * p);
              }
            } else {
              _this9.instance.delta[_this9.directionAxis] = scrollStart + scrollDiff * p;
            }
          }; // Prepare the scroll

          this.animatingScroll = true; // This boolean allows to prevent `checkScroll()` from calling `stopScrolling` when the animation is slow (i.e. at the beginning of an EaseIn)

          this.stopScrolling(); // Stop any movement, allows to kill any other `scrollTo` still happening

          this.startScrolling(); // Restart the scroll
          // Start the animation loop

          var start = Date.now();
          var loop = function loop() {
            var p = (Date.now() - start) / duration; // Animation progress

            if (p > 1) {
              // Animation ends
              render(1);
              _this9.animatingScroll = false;
              if (duration == 0) _this9.update();
              if (callback) callback();
            } else {
              _this9.scrollToRaf = requestAnimationFrame(loop);
              render(easing(p));
            }
          };
          loop();
        }
      }, {
        key: "update",
        value: function update() {
          this.setScrollLimit();
          this.addSections();
          this.addElements();
          this.detectElements();
          this.updateScroll();
          this.transformElements(true);
          this.reinitScrollBar();
          this.checkScroll(true);
        }
      }, {
        key: "startScroll",
        value: function startScroll() {
          this.stop = false;
        }
      }, {
        key: "stopScroll",
        value: function stopScroll() {
          this.stop = true;
        }
      }, {
        key: "setScroll",
        value: function setScroll(x, y) {
          this.instance = _objectSpread2(_objectSpread2({}, this.instance), {}, {
            scroll: {
              x: x,
              y: y
            },
            delta: {
              x: x,
              y: y
            },
            speed: 0
          });
        }
      }, {
        key: "destroy",
        value: function destroy() {
          _get(_getPrototypeOf(_default.prototype), "destroy", this).call(this);
          this.stopScrolling();
          this.html.classList.remove(this.smoothClass);
          this.vs.destroy();
          this.destroyScrollBar();
          window.removeEventListener('keydown', this.checkKey, false);
        }
      }]);
      return _default;
    }(_default);
    var Smooth = /*#__PURE__*/function () {
      function Smooth() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        _classCallCheck(this, Smooth);
        this.options = options; // Override default options with given ones

        Object.assign(this, defaults, options);
        this.smartphone = defaults.smartphone;
        if (options.smartphone) Object.assign(this.smartphone, options.smartphone);
        this.tablet = defaults.tablet;
        if (options.tablet) Object.assign(this.tablet, options.tablet);
        if (!this.smooth && this.direction == 'horizontal') console.warn('🚨 `smooth:false` & `horizontal` direction are not yet compatible');
        if (!this.tablet.smooth && this.tablet.direction == 'horizontal') console.warn('🚨 `smooth:false` & `horizontal` direction are not yet compatible (tablet)');
        if (!this.smartphone.smooth && this.smartphone.direction == 'horizontal') console.warn('🚨 `smooth:false` & `horizontal` direction are not yet compatible (smartphone)');
        this.init();
      }
      _createClass(Smooth, [{
        key: "init",
        value: function init() {
          this.options.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1 || window.innerWidth < this.tablet.breakpoint;
          this.options.isTablet = this.options.isMobile && window.innerWidth >= this.tablet.breakpoint;
          if (this.smooth && !this.options.isMobile || this.tablet.smooth && this.options.isTablet || this.smartphone.smooth && this.options.isMobile && !this.options.isTablet) {
            this.scroll = new _default$2(this.options);
          } else {
            this.scroll = new _default$1(this.options);
          }
          this.scroll.init();
          if (window.location.hash) {
            // Get the hash without the '#' and find the matching element
            var id = window.location.hash.slice(1, window.location.hash.length);
            var target = document.getElementById(id); // If found, scroll to the element

            if (target) this.scroll.scrollTo(target);
          }
        }
      }, {
        key: "update",
        value: function update() {
          this.scroll.update();
        }
      }, {
        key: "start",
        value: function start() {
          this.scroll.startScroll();
        }
      }, {
        key: "stop",
        value: function stop() {
          this.scroll.stopScroll();
        }
      }, {
        key: "scrollTo",
        value: function scrollTo(target, options) {
          this.scroll.scrollTo(target, options);
        }
      }, {
        key: "setScroll",
        value: function setScroll(x, y) {
          this.scroll.setScroll(x, y);
        }
      }, {
        key: "on",
        value: function on(event, func) {
          this.scroll.setEvents(event, func);
        }
      }, {
        key: "off",
        value: function off(event, func) {
          this.scroll.unsetEvents(event, func);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.scroll.destroy();
        }
      }]);
      return Smooth;
    }();
    return Smooth;
  });
};
/* harmony default export */ __webpack_exports__["default"] = (LocomotiveScroll());
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "../node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ })

/******/ });
//# sourceMappingURL=main.min.js.map